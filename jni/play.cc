// Generated by Neo

#include <sstream>
#include <unistd.h>
#include <pthread.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include "string.h"
#include "play.h"
#include "defines.h"
#include "utils/commons.h"
#include "utils/threads.h"
#include "utils/callbacks.h"
#include "utils/voiceenc.h"
#include "utils/char_conv.h"
#include "utils/playmp4.h"

#include <nplayer/nplayer.h>
#include <nplayer/handler.h>


#include "utils/playhls.h"
#include <alu/audio_record.h>

#ifdef _USE_OPENAL_
#include <alu/openal_utils.h>
#else
#include <alu/audio_track.h>
#endif

#include <json.h>
#include <net_interface.h>

const unsigned int kMaxMP4VideoWidth = 1280;
const unsigned int kMaxMP4VideoHeight = 720;


#define FRAMESIZE 640

bool has_inited;
bool has_link_enabled;

JAE_HANDLE audio_encoder;

class EchoHandler: public utils::Handler {
public:
	EchoHandler() {
	}
	~EchoHandler() {
	}

	bool handle(int what, int arg1, int arg2, void *obj) {
		LOGI("echo: %d, %d, %d, %p", what, arg1, arg2, obj);
		return false;
	}

private:
	ONLY_EMPTY_CONSTRUCTION(EchoHandler);
};

EchoHandler* handler = NULL;

FILE *dummyFile = NULL;
nplayer::NPlayer *new_nplayer = NULL;
nplayer::PlaySuit suit;
int channel_index = 1; //记录设备的通道号，发送音频数据时使用
float adjust_volume = 1.0;//
using namespace Json;

JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {

	LOGV("player version = %s", nplayer::NPlayer::version());

	g_jvm = vm;
	has_inited = false;
	g_enable_log = false;
	has_link_enabled = false;

	nplayer::NPlayer::init();

	memset(&suit, 0, sizeof(nplayer::PlaySuit));
	suit.window = 1;
	suit.audio_sample_rate = 8000;
	suit.audio_frame_block = FRAMESIZE;
	suit.audio_channel_per_frame = 1;
	suit.audio_bit_per_channel = 16;
	suit.audio_type = nplayer::kATypeRawPCM;

	suit.enable_denoise = true;
	suit.enable_vad = false;
	suit.noise_suppress = -24;

	handler = new EchoHandler();

	dummyFile = fopen(DUMMY_FILE, "wb");

	return JNI_VERSION_1_6;
}

// audio dec
//JAD_HANDLE	    adec			= NULL;
int				iDecodedBytes	= 0;
unsigned char *	pszPcm			= {0};

unsigned char		szPcmBuf[640]	= {0};
void fetchd(const nplayer::byte *data, size_t size, uint64_t ts) {
//	LOGV("fetched: %p, %d, %llu", data, size, ts);
	unsigned char* enc_data ;

	if(NULL != audio_encoder){
	    int result = JAE_EncodeOneFrameEx(audio_encoder,(unsigned char*)data,
	    		&enc_data);

	    if(NULL != dummyFile){
//	    	LOGV("fetched: %p, %d, %llu", data, size, ts);
	    	fwrite(data,size,1,dummyFile);
	    }

//	    LOGI("encode size %d index %d",result,channel_index);
//	    if(320 == result)
	        JVC_SendData(channel_index, JVN_RSP_CHATDATA, enc_data, result);
	}
}

void JNI_OnUnload(JavaVM* vm, void* reserved) {
	jboolean needDetach = JNI_FALSE;
	JNIEnv* env = genAttachedEnv(vm, JNI_VERSION_1_6, &needDetach);
	if (NULL != env) {
		if (NULL != g_handle && NULL != g_notifyid) {
			// [Neo] call back
			env->CallVoidMethod(g_handle, g_notifyid, CALL_LIB_UNLOAD, (jint) 0,
					(jint) 0, NULL);
		}

		if (JNI_TRUE == needDetach) {
			g_jvm->DetachCurrentThread();
		}
	}

	delete handler;
	nplayer::NPlayer::deinit();
}

JNIEXPORT jstring JNICALL Java_com_jovision_Jni_getVersion(JNIEnv *env,
		jclass clazz) {
	// [Neo] man did
	string result = "{\"jni\":\"";
	result += MY_VERSION;
	result += REVISION;
	result += RELEASE_DATE;
	result += "\",\"net\":\"";
	result += JVC_GetVersion();
	result += "\"}";
	return env->NewStringUTF(result.c_str());
}

void* send_wav(void* msg) {
	FILE* file = fopen("/sdcard/rec.pcm", "rb");
//	FILE* file = fopen("/sdcard/baby.wav", "rb");
	if (NULL == audio_encoder) {
		JAE_PARAM param = { 0 };
		param.iCodecID = 2;
		param.sample_rate = 8000;
		param.channels = 1;
		param.bits_per_sample = 16;
		param.bytes_per_block = 640;

		audio_encoder = JAE_EncodeOpenEx(&param);
	}

	unsigned char* buffer = (unsigned char*) malloc(640);

	int encoded = 0;
	unsigned char* out = NULL;

	LOGE("send in");

	while (NULL != audio_encoder && fread(buffer, 640, 1, file) > 0) {
		encoded = JAE_EncodeOneFrameEx(audio_encoder, buffer, &out);
		if (320 == encoded) {
			JVC_SendData(1, JVN_RSP_CHATDATA, out, encoded);
		}
		msleep(40);
	}

	if (NULL != audio_encoder) {
		JAE_EncodeCloseEx(audio_encoder);
		audio_encoder = NULL;
	}

	free(buffer);
	fclose(file);

	LOGE("send out");

	return NULL;
}

void fetch_cb(const unsigned char* data, size_t length) {
	static int aaa = 0;
	static FILE* fout = NULL;
	aaa++;
	if (aaa == 1) {
		fout = fopen("/sdcard/rec.pcm", "wb");
		LOGXX("start write");
	}

	int encoded = 0;
	unsigned char* out = NULL;
	if (NULL != data && NULL != audio_encoder) {
		encoded = JAE_EncodeOneFrameEx(audio_encoder, (unsigned char *) data,
				&out);
		if (320 == encoded) {
			JVC_SendData(1, JVN_RSP_CHATDATA, out, encoded);
		}
	}

	if (fout) {
		if (NULL != data) {
			fwrite(data, length, 1, fout);
		} else {
			fclose(fout);
			LOGXX("write done");

			aaa = 0;
			fout = NULL;
		}
	}
}

void report_cb(ReportWhat what, ReportArg1 arg1, ReportArg2 arg2,
		const void* data) {
	if (k2Stopped == arg2 || k2AutoStopped == arg2) {
		switch (what) {
		case kWhatALU:
#ifdef _USE_OPENAL_
//			delete (OpenALUtils*) data;
#endif
			break;

		case kWhatTrack: {
			delete (AudioTrack*) data;

			jboolean needDetach = JNI_FALSE;
			JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
			if (NULL != env) {
				if (NULL != g_handle && NULL != g_notifyid) {
					// [Neo] call back
					env->CallVoidMethod(g_handle, g_notifyid, CALL_GEN_VOICE,
							(jint) 0, (jint) 0, NULL);
				}

				if (JNI_TRUE == needDetach) {
					g_jvm->DetachCurrentThread();
				}
			}
		}
			break;

		default:
			break;
		}
	}
}

void play() {
	int buffer_length = 640;
	FILE* f = fopen("/sdcard/baby.wav", "rb");
	unsigned char* bytes = (unsigned char*) malloc(buffer_length);

#ifdef _USE_OPENAL_
	OpenALUtils* utils = new OpenALUtils();
	utils->start(kRateDefault, kChannelMono, kPCM16bit, NULL);
#else
	AudioTrack* track = new AudioTrack();
	track->start(kRateDefault, kChannelMono, kPCM16bit, report_cb);
#endif

	while (fread(bytes, buffer_length, 1, f) > 0) {
#ifdef _USE_OPENAL_
		utils->append(bytes, buffer_length);
#else
		track->append(bytes, buffer_length);
#endif
		msleep(10);
	}
	fclose(f);
}

JNIEXPORT jbyteArray JNICALL Java_com_jovision_Jni_foo(JNIEnv *env,
		jclass clazz, jbyteArray array) {
	jbyteArray result = NULL;

//	size_t size = 1024 * 1024 * 10;
//	jbyte* buffer = (jbyte*) malloc(size);
//	result = genByteArray(env, buffer, 0, size);

//	play();

//	pthread_t pid;
//	pthread_create(&pid, NULL, send_wav, NULL);

	return result;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_setStat(JNIEnv *env, jclass clazz,
		jboolean on) {
	LOGV("setStat E: %d", on);

	if ((JNI_TRUE == on) != g_is_stat_mode) {
		g_is_stat_mode = (JNI_TRUE == on);

		if (g_is_stat_mode) {
			// [Neo] start stat thread
			pthread_t pt;
			pthread_create(&pt, NULL, onStat, NULL);
		}
	}

	LOGV("setStat X");
}

void shutdown_audio() {
	if (NULL != audio_encoder) {
		JAE_EncodeCloseEx(audio_encoder);
		audio_encoder = NULL;
	}

	if (NULL != new_nplayer) {
		new_nplayer->stop_record_audio();
		new_nplayer->enable_audio(false);

		msleep(150);

		if (NULL != new_nplayer) {
			delete new_nplayer;
			new_nplayer = NULL;
		}
	}
}

void *append_by_file(void *handle) {
	dummyFile = fopen(DUMMY_FILE, "rb");
//	LOGW("append E");
	if (NULL != dummyFile) {
		nplayer::byte *buffer = static_cast<nplayer::byte *>(malloc(FRAMESIZE));
		if (NULL != new_nplayer) {
			while (fread(buffer, FRAMESIZE, 1, dummyFile) > 0) {
				while (new_nplayer->audio_working()
						&& false
								== new_nplayer->append_audio_data(buffer, FRAMESIZE)) {
					msleep(100);
				}

				if (false == new_nplayer->audio_working()) {
					break;
				}
			}
		}
		free(buffer);

//	LOGW("append X");

		if (NULL != dummyFile) {
//			fclose(dummyFile);
			dummyFile = NULL;
		}
	}

	return NULL;
}

void initNPlayer() {
	shutdown_audio();
	dummyFile = fopen(DUMMY_FILE, "wb");

	suit.enable_denoise = true;
	new_nplayer = new nplayer::NPlayer(&suit, handler);
	new_nplayer->resume();
	new_nplayer->enable_audio(true);
	new_nplayer->adjust_track_volume(adjust_volume);
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_initDenoisePlayer(JNIEnv* env,
		jclass clz){
	initNPlayer();
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_setAdjustVolume(JNIEnv* env,
		jclass clz,jfloat f){
	if(fabsf(f)>0.00001)
		adjust_volume = f;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_recordAndsendAudioData(JNIEnv* env,
		jclass clz,jint channelindex) {

//	initNPlayer();

	if (NULL == audio_encoder) {
		JAE_PARAM param = { 0 };
		param.iCodecID = 2;
		param.sample_rate = 8000;
		param.channels = 1;
		param.bits_per_sample = 16;
		param.bytes_per_block = 640;

		audio_encoder = JAE_EncodeOpenEx(&param);
//		adec = JAD_DecodeOpenEx(2);
	}

	int index = channelindex+1;
	if(index > 1)
		channel_index = index;

	new_nplayer->start_record_audio(fetchd);

	LOGI("rec on");
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_stopDenoisePlayer(JNIEnv* env,
		jclass clz){
	shutdown_audio();
	if (NULL != dummyFile) {
		fclose(dummyFile);
		dummyFile = NULL;
	}
	LOGI("rec stop");
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_resumeRecordAudio(JNIEnv* env,
		jclass clz){
	if(NULL == new_nplayer){
		new_nplayer->resume();
	}

	LOGI("rec resume");
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_pauseRecordAudio(JNIEnv* env,
		jclass clz) {
	if(NULL == new_nplayer){
		new_nplayer->pause();
	}

	LOGI("rec pause");
}

void printHex(byte *data)
{
	int size;
	size = sizeof(data);
	for (int var = 0; var < size; ++var) {
		LOGI("0x%x",*(data+var));
	}
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_playAudioData(JNIEnv* env,
		jclass clz ,jbyteArray data) {

	if(data == NULL)
		return;

	jsize size = env->GetArrayLength(data);
	jbyte* in = getNativeByteByLength(env, data, 0, size);
	if (NULL != new_nplayer) {
		printHex((byte *)in);
		new_nplayer->append_audio_data((byte *)in, size);
//		LOGI("rec play %d",size);
	}

//	append_by_file(NULL);
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_playOn(JNIEnv* env,
		jclass clz) {
	shutdown_audio();

	suit.enable_denoise = true;
	new_nplayer = new nplayer::NPlayer(&suit, handler);
	new_nplayer->resume();
	new_nplayer->enable_audio(true);
//	new_nplayer->adjust_track_volume(10.0f);

	pthread_t pid;
	pthread_create(&pid, NULL, append_by_file, NULL);

	LOGI("play on");
	return JNI_FALSE;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_startAudioRecord(JNIEnv* env,
		jclass clz, jint bit, jint block) {
	jboolean result = JNI_FALSE;

	if (NULL != AudioRecord::getInstance(g_jvm)) {
		result =
				(AudioRecord::getInstance(g_jvm)->start(kRateDefault,
						kChannelMono,
						((kPCM8bit == bit || 8 == bit) ? kPCM8bit : kPCM16bit),
						block, fetch_cb)) ? JNI_TRUE : JNI_FALSE;

		if (NULL == audio_encoder) {
			JAE_PARAM param = { 0 };
			param.iCodecID = 2;
			param.sample_rate = 8000;
			param.channels = 1;
			param.bits_per_sample = 16;
			param.bytes_per_block = 640;

			audio_encoder = JAE_EncodeOpenEx(&param);
		}

	}

	LOGE("start record: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_stopAudioRecord(JNIEnv* env,
		jclass clz) {
	jboolean result = JNI_FALSE;

	if (NULL != AudioRecord::getInstance(g_jvm)) {
		if (NULL != audio_encoder) {
			JAE_EncodeCloseEx(audio_encoder);
			audio_encoder = NULL;
		}

		result =
				(AudioRecord::getInstance(g_jvm)->stop()) ? JNI_TRUE : JNI_FALSE;
	}

	LOGE("stop record: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setRecordVolume(JNIEnv* env,
		jclass clz, jfloat volume) {
	jboolean result = JNI_FALSE;

	if (NULL != AudioRecord::getInstance(g_jvm)) {
		AudioRecord::getInstance(g_jvm)->set_volume(volume);
		result = JNI_TRUE;
	}

	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_init(JNIEnv *env, jclass clazz,
		jobject handle, jint port, jstring path) {
	jboolean result = JNI_FALSE;
	LOGX(
			"play: %s%s%s, net: %s", MY_VERSION, REVISION, RELEASE_DATE, JVC_GetVersion());

	if (false == has_inited) {
		char* cpath = getNativeChar(env, path);
		LOGV("init E: %p, %d, %s", (void*) handle, port, cpath);

		// [Neo] get java vm ref and make handle global
		env->GetJavaVM(&g_jvm);
		g_handle = env->NewGlobalRef(handle);

		// [Neo] the only one notify callback
		jclass clz = env->GetObjectClass(g_handle);
		g_notifyid = env->GetMethodID(clz, "onJniNotify",
				"(IIILjava/lang/Object;)V");

#ifdef DEBUG_LOG
		g_enable_log = true;
#endif
		g_has_omx_inited = false;
		g_is_stat_mode = false;
		g_is_record_mode = false;

		// [Neo] clean indexes
		for (int i = 0; i < MAX_WINDOW_COUNT; i++) {
			g_player[i] = NULL;
			g_connect_indexes[i] = BAD_NOT_CONNECT;
		}

		// [Neo] init decoder, and precheck hdec
		JVD04_InitSDK();
		JVD05_InitSDK();

		g_download_file = NULL;
		g_download_file_name = NULL;

		pthread_mutex_init(&(g_mutex), NULL);
		g_hdec_instance_count = 0;
		g_has_omx_inited = (JHD05_InitSDK(g_jvm) > 0);
		JHD_SetCallBack_OmxInfo(onOmxInfo);

		// [Neo] screenshoter
		g_jpg = yuv_jpg_init();

		g_thumb_width = 320;
		g_thumb_quality = 70;
		g_picture_quality = 80;

		// [Neo] and recorder suit
		size_t size = sizeof(recorder_suit);
		g_recorder = (recorder_suit*) malloc(size);
		memset(g_recorder, 0, size);

		g_recorder->handle = NULL;
		g_recorder->need_jump = true;
		g_recorder->enable_audio = false;
		g_recorder->enable_video = false;
		g_recorder->window = -1;
		pthread_mutex_init(&(g_recorder->mutex), NULL);

		// [Neo] mp4 packet
		JP_InitSDK(128 * 1024, 1);

		// [Neo] finally, network and callbacks
		result = (JVC_InitSDK(port, cpath)) ? JNI_TRUE : JNI_FALSE;
		JVC_RegisterCallBack(ConnectChange, NormalData, CheckResult, ChatData,
				TextData, Download, PlayData);

		// [Neo] set working flag
		has_inited = true;
		free(cpath);

	} else {
		LOGE("init with nonsense!!");
	}

	LOGV("init X: %d", result);
	return result;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_deinit(JNIEnv *env, jclass clazz) {
	LOGV("deinit E");

	if (has_inited) {
		has_inited = false;
		has_link_enabled = false;

		pthread_mutex_destroy(&(g_mutex));

		if (NULL != g_download_file) {
			fclose(g_download_file);
			g_download_file = NULL;
		}

		if (NULL != g_download_file_name) {
			free(g_download_file_name);
			g_download_file_name = NULL;
		}

		if (NULL != g_handle) {
			env->DeleteGlobalRef(g_handle);
			g_handle = NULL;
		}

		if (NULL != g_recorder) {
			pthread_mutex_destroy(&(g_recorder->mutex));
			free(g_recorder);
			g_recorder = NULL;
		}

		if (NULL != g_jpg) {
			yuv_jpg_destroy(g_jpg);
			g_jpg = NULL;
		}

//		AudioRecord::destory();
//		OpenALUtils::deinit();

		JP_ReleaseSDK();
		JHD05_ReleaseSDK();
		JVD05_ReleaseSDK();
		JVD04_ReleaseSDK();

		// [Neo] so bad
//		JVC_ReleaseSDK();

	} else {
		LOGE("deinit with nonsense!!");
	}

	LOGV("deinit X");
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_clearCache(JNIEnv *, jclass) {
	JVC_ClearHelpCache();
	LOGV("clear help cache done");
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_resumeAudio(JNIEnv *, jclass,
		jint window) {
	jboolean result = JNI_FALSE;
	LOGX( "resumeAudio E: window = %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player) {
			pthread_mutex_lock(&(player->stat->mutex));

//			if (NULL != player->track) {
//				result = player->track->resume() ? JNI_TRUE : JNI_FALSE;
//			}

			if(NULL != player->nplayer){
				result = player->nplayer->resume()? JNI_TRUE : JNI_FALSE ;
			}

			pthread_mutex_unlock(&(player->stat->mutex));
		}
	}

	LOGX( "resumeAudio: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_pauseAudio(JNIEnv *, jclass,
		jint window) {
	jboolean result = JNI_FALSE;
	LOGX( "pauseAudio E: window = %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player) {
			pthread_mutex_lock(&(player->stat->mutex));
//			if (NULL != player->track) {
//				result = player->track->pause() ? JNI_TRUE : JNI_FALSE;
//			}

			if (NULL != player->nplayer){
				result = player->nplayer->pause()? JNI_TRUE : JNI_FALSE;
			}

			pthread_mutex_unlock(&(player->stat->mutex));
		}
	}

	LOGX( "pauseAudio X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_pause(JNIEnv* env,
		jclass clazz, jint window) {
	jboolean result = JNI_FALSE;
	LOGX( "pause E: window = %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && NULL != player->core) {
			LOGV( "pausing [%d] = %d", window, index);
			result = glPause(player) ? JNI_TRUE : JNI_FALSE;
			BYTE* o = (BYTE*) malloc(DUMMY_FRAME_SIZE);
			memset(o, 0, DUMMY_FRAME_SIZE);
			o[0] = DUMMY_FRAME_THUMB;
			offer_video_frame(player, o, DUMMY_FRAME_SIZE, 0);

			// [Neo] disable audio automatic
			player->is_play_audio = false;

			pthread_mutex_lock(&(player->stat->mutex));
#ifdef _USE_OPENAL_
			if (NULL != player->alu) {
				player->alu->pause();
			}
#else
			if (NULL != player->track) {
				player->track->pause();
			}
#endif
			pthread_mutex_unlock(&(player->stat->mutex));

		}
	} else {
		LOGE("pause %d not connect", window);
	}

	LOGX( "pause X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_resume(JNIEnv* env,
		jclass clazz, jint window, jobject surface) {
	jboolean result = JNI_FALSE;
	LOGX( "resume E: window = %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && NULL != player->core) {
			LOGV(
					"resuming [%d] = %d, yuv = %p", window, index, player->core->yuv);
			if (glResume(env, player, surface)) {
				result = JNI_TRUE;
			}

			BYTE* o = (BYTE*) malloc(DUMMY_FRAME_SIZE);
			memset(o, 0, DUMMY_FRAME_SIZE);
			o[0] = DUMMY_FRAME_DIRTY;
			offer_video_frame(player, o, DUMMY_FRAME_SIZE, 0);

			pthread_mutex_lock(&(player->stat->mutex));
#ifdef _USE_OPENAL_
			if (NULL != player->alu) {
				player->alu->resume();
			}
#else
			if (NULL != player->track) {
				player->track->resume();
			}
#endif
			pthread_mutex_unlock(&(player->stat->mutex));

		}
	} else {
		LOGE("resume %d not connect", window);
	}

	LOGX( "resume X: %d", result);
	return result;
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_connect(JNIEnv *env, jclass clazz,
		jint window, jint channel, jstring ip, jint port, jstring username,
		jstring password, jint cloudSeeId, jstring groupId,
		jboolean isLocalDetect, jint turnType, jboolean isPhone,
		jint connectType, jobject surface, jboolean isVip, jboolean isTcp,
		jboolean isAp, jboolean isTryOmx, jstring thumbName) {
	jint result = BAD_CONN_UNKOWN;
	char* cip = getNativeChar(env, ip);
	char* user = getNativeChar(env, username);
	char* pwd = getNativeChar(env, password);
	char* gid = getNativeChar(env, groupId);

	int nVip = (JNI_TRUE == isVip) ? 1 : 0;
	int nTcp = (JNI_TRUE == isTcp) ? 1 : 0;
	LOGV(
			"connect E: window: %d, channel: %d, host: %s:%d, username: %s, password: %s, no: %s%d, isLocalDetect: %d, turnType: %d, isPhone: %d, connectType: %d, surface: %p, isTryOmx: %d, vip: %d, tcp: %d, ap: %d", window, channel, cip, port, user, pwd, gid, cloudSeeId, isLocalDetect, turnType, isPhone, connectType, (void*) surface, isTryOmx, nVip, nTcp, isAp);

	int index = getValidArrayIndex(window);
	bool is_play_directly = false;

	if (index >= 0) {
		player_suit* player = genPlayer(index);
		player->thumb_name = getNativeChar(env, thumbName);

		if (NULL != surface) {
			// [Neo] check attach result
			if (glAttach(env, player, surface)) {
				is_play_directly = true;
			} else {
				LOGW( "connect[%d], attach failed, work without video", window);
			}
		}

		player->try_omx = false;

		if (JNI_TRUE == isTryOmx) {
			player->try_omx = g_has_omx_inited;
		}

		// [Neo] start the play video thread
		pthread_t pt;
		pthread_create(&pt, NULL, onPlayVideo, (void*) index);

		if (JNI_FALSE == isAp) {
			// [Neo] and connect indeed
			JVC_Connect(index + 1, channel, cip, port, user, pwd, cloudSeeId,
					gid, (isLocalDetect == JNI_TRUE) ? true : false, turnType,
					(isPhone == JNI_TRUE) ? true : false, connectType,
					is_play_directly, nVip, nTcp);
		} else {
			//2015.4.22 jy锟斤拷锟斤拷锟斤拷锟斤拷锟�sdk娣�锟斤拷锟借��锟姐��锟姐�ワ拷锟� 锟斤拷锟芥��锟藉�告��锟斤拷���锟�isAp���缁�锟斤拷娑�锟界��锟芥��锟�true
			JVC_Connect(index + 1, 1, "10.10.0.1", 9101, user,
					pwd, -1, "A", false, false, true, 5, true, 0, 0);
		}
		result = window;

	} else {
		result = index;
		switch (index) {
		case BAD_HAS_CONNECTED:
			LOGE( "connect[%d], has connected!!", window);
			break;

		case BAD_CONN_OVERFLOW:
			LOGE(
					"connect[%d], over max support count(%d)!!", window, MAX_WINDOW_COUNT);
			break;

		default:
			result = BAD_CONN_UNKOWN;
			LOGE( "connect[%d], unknown error!!", window);
			break;
		}
	}

	free(cip);
	free(user);
	free(pwd);
	free(gid);

	LOGV("connect X, result: %d", result);

	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_connectRTMP(JNIEnv *env,
		jclass clazz, jint window, jstring url, jobject surface,
		jboolean isTryOmx, jstring thumbName,jint nTimeout) {
	jboolean result = JNI_FALSE;
	char* curl = getNativeChar(env, url);
	int index = getValidArrayIndex(window);

	if (index >= 0) {
		player_suit* player = genPlayer(index);
		player->thumb_name = getNativeChar(env, thumbName);

		if (NULL != surface && glAttach(env, player, surface)) {
			player->try_omx = false;
			player->is_play_audio = true;

			if (JNI_TRUE == isTryOmx) {
				player->try_omx = g_has_omx_inited;
			}

			// [Neo] start the play video thread
			pthread_t pt;
			pthread_create(&pt, NULL, onPlayVideo, (void*) index);

			result =
					(JVC_ConnectRTMP(index + 1, curl, ConnectChangeRTMP,
							NormalDataRTMP,nTimeout)) ? JNI_TRUE : JNI_FALSE;

		} else {
			LOGW( "connectRTMP[%d], attach failed", window);
			deletePlayer(index);
		}
	}

	free(curl);

	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_shutdownRTMP(JNIEnv *env,
		jclass clazz, jint window) {
	jboolean result = JNI_FALSE;

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];

		if (NULL != player) {
			if (false == player->is_disconnecting) {
				player->is_disconnecting = true;
			} else {
				LOGE("player(window = %d) has called disconnect!", window);
			}
		} else {
			LOGE("player(window = %d) is NULL!", window);
		}

		JVC_ShutdownRTMP(index + 1);
		result = JNI_TRUE;
	}

	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_disconnect(JNIEnv *env,
		jclass clazz, jint window) {
	jboolean result = JNI_FALSE;
	LOGV("disconnect E: window: %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];

		if (NULL != player) {
			if (false == player->is_disconnecting) {
				player->is_disconnecting = true;
			} else {
				LOGE("player(window = %d) has called disconnect!", window);
			}
		} else {
			LOGE("player(window = %d) is NULL!", window);
		}

		JVC_DisConnect(index + 1);
		result = JNI_TRUE;
	} else {
		LOGE("disconnect %d not connect", window);
	}

	LOGV("disconnect X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_sendBytes(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jbyteArray data, jint size) {
	jboolean result = JNI_FALSE;
	LOGX("sendBytes E: window = %d", window);

	jbyte* cdata = getNativeByteByLength(env, data, 0, size);
	if (size < 16) {
		char* echo = byte2echo((BYTE*) cdata, 0, size);
		LOGV(
				"sendBytes: window: %d, type: 0x%X, array: %s", window, uchType, echo);
		free(echo);
	} else {
		LOGV(
				"sendBytes: window: %d, type: 0x%X, %d bytes", window, uchType, size);
	}

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) cdata, size);
		result = JNI_TRUE;
	} else {
		LOGE("sendBytes %d not connect", window);
	}

	free(cdata);
	LOGX("sendBytes X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_sendSuperBytes(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jboolean isExtended,
		jint count, jint type, jint p1, jint p2, jint p3, jbyteArray data,
		jint size) {
	jboolean result = JNI_FALSE;
	LOGX("sendSuperBytes E: window = %d", window);
	jbyte* cdata = getNativeByteByLength(env, data, 0, size);

	int index = window2Array(window);
	if (index >= 0) {
		PAC packet;
		memset(&packet, 0, sizeof(PAC));
		result = JNI_TRUE;

		if (JNI_TRUE == isExtended) {
			packet.nPacketType = RC_EXTEND;
			packet.nPacketCount = count;

			EXTEND* pExt;
			pExt = (EXTEND*) packet.acData;
			pExt->acData[0] = 0;
			pExt->nType = type;
			pExt->nParam1 = p1;
			pExt->nParam2 = p2;
			pExt->nParam3 = p3;

			if (NULL != cdata) {
				memcpy(pExt->acData, cdata, size);
			}

			LOGX(
					"sendSuperBytes: %u, %u, %u, %u; %d, %d, %d, %d; size = %d", packet.nPacketType, packet.nPacketCount, packet.nPacketID, packet.nPacketLen, pExt->nType, pExt->nParam1, pExt->nParam2, pExt->nParam3, size);

			JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet, size + 20);
		} else {
			packet.nPacketType = type;

			if (NULL != cdata) {
				memcpy(packet.acData, cdata, size);
			}

			LOGX(
					"sendSuperBytes: %u, %u, %u, %u; size = %d", packet.nPacketType, packet.nPacketCount, packet.nPacketID, packet.nPacketLen, size);

			JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet, size + 4);
		}

	} else {
		LOGE("sendSuperBytes %d not connect", window);
	}

	free(cdata);
	LOGX("sendSuperBytes X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_sendPrimaryBytes(JNIEnv *env,
		jclass clazz, jint window, jbyte data_type, jint packet_type,
		jint packet_count, jint extend_type, jint extend_p1, jint extend_p2,
		jint extend_p3, jbyteArray data, jint size) {
	jboolean result = JNI_FALSE;
	jbyte* cdata = getNativeByteByLength(env, data, 0, size);

	int index = window2Array(window);
	if (index >= 0) {
		PAC packet;
		memset(&packet, 0, sizeof(PAC));
		result = JNI_TRUE;

		packet.nPacketType = packet_type;
		packet.nPacketCount = packet_count;

		EXTEND* pExt;
		pExt = (EXTEND*) packet.acData;
		pExt->nType = extend_type;
		pExt->nParam1 = extend_p1;
		pExt->nParam2 = extend_p2;
		pExt->nParam3 = extend_p3;

		pExt->acData[0] = 0;
		if (NULL != cdata && size > 0) {
			memcpy(pExt->acData, cdata, size);
			pExt->acData[size] = 0;
		}

		LOGX(
				"sendPrimaryBytes: %u, %u, %u, %u; %d, %d, %d, %d; size = %d", packet.nPacketType, packet.nPacketCount, packet.nPacketID, packet.nPacketLen, pExt->nType, pExt->nParam1, pExt->nParam2, pExt->nParam3, size);

		JVC_SendData(index + 1, (BYTE) data_type, (BYTE*) &packet, size + 20);
	}

	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_sendInteger(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jint data) {
	jboolean result = JNI_FALSE;
	LOGX("sendInteger E: window = %d, data = %d", result, data);

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &data, 4);
		result = JNI_TRUE;
	} else {
		LOGE("sendInteger %d not connect", window);
	}

	LOGX("sendInteger X: %d", result);
	return result;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_enableLog(JNIEnv *env,
		jclass clazz, jboolean enable) {
	LOGV( "enableLog E: %d => %d", g_enable_log, enable);
	g_enable_log = (JNI_TRUE == enable);
	JVC_EnableLog(g_enable_log);
	LOGV( "enableLog X");
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_deleteLog(JNIEnv* env,
		jclass clazz) {
	LOGV( "deleteLog E");
	JVC_DeleteErrorLog();
	LOGV( "deleteLog X");
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_enablePlayback(JNIEnv *env,
		jclass clazz, jint window, jboolean enable) {
	jboolean result = JNI_FALSE;
	LOGV("enablePlayback E: window: %d, enable: %d", window, enable);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && player->is_connected) {
			bool is_enable = (JNI_TRUE == enable) ? true : false;
			if (is_enable != player->is_playback_mode) {
				player->is_playback_mode = is_enable;
				clean_all_queue(player);
			}
			result = JNI_TRUE;
		}
	} else {
		LOGE("enablePlayback %d not connect", window);
	}

	LOGV("enablePlayback X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_isPlayback(JNIEnv* env,
		jclass clazz, jint window) {
	jboolean result = JNI_FALSE;
	LOGV("isPlayback E: window: %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player) {
			result = (player->is_playback_mode) ? JNI_TRUE : JNI_FALSE;
		}
	} else {
		LOGE("isPlayback %d not connect", window);
	}

	LOGV("isPlayback X, %d", result);
	return result;
}

#ifndef CASTRATE

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_sendString(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jboolean isExtended,
		jint count, jint type, jstring data) {
	jboolean result = JNI_FALSE;
	char* cdata = NULL;

	if (NULL != data) {
		cdata = getNativeChar(env, data);
	}

	bool isExt = (JNI_TRUE == isExtended) ? true : false;
	LOGV(
			"sendString E: window: %d, type: %X, isExtended: %d, count: %d, type: %d, str: %s", window, uchType, isExt, count, type, cdata);

	int index = window2Array(window);
	if (index >= 0) {
		PAC packet;
		memset(&packet, 0, sizeof(PAC));
		result = JNI_TRUE;

		if (isExt) {
			packet.nPacketType = RC_EXTEND;
			packet.nPacketCount = count;

			EXTEND* pExt;
			pExt = (EXTEND*) packet.acData;
			pExt->acData[0] = 0;
			pExt->nType = type;

			if (NULL != cdata) {
				strcat(pExt->acData, cdata);
			}

			JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
					strlen(pExt->acData) + 20);
		} else {
			packet.nPacketType = type;

			if (NULL != cdata) {
				sprintf(packet.acData, "%s", cdata);
			}

			JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
					strlen(packet.acData) + 20);
		}
	} else {
		LOGE("sendString %d not connect", window);
	}

	if (NULL != cdata) {
		free(cdata);
	}

	LOGV( "sendString X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_sendAudioData(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jbyteArray data, jint size) {
	jboolean result = JNI_FALSE;
	jbyte* cdata = getNativeByteByLength(env, data, 0, size);
	int index = window2Array(window);
	if (index >= 0) {
		BYTE* converted = convertAudioData(cdata);
		JVC_SendData(index + 1, (BYTE) uchType, converted, 320);
		free(converted);
		result = JNI_TRUE;
	} else {
		LOGE("sendAudioData %d not connect", window);
	}

	free(cdata);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_sendTextData(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jint size, jint type) {
	jboolean result = JNI_FALSE;
	LOGV(
			"sendTextData E: window: %d, type: 0x%X, size: %d, type: %X", window, uchType, size, type);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));

	switch (type) {
	case TEXT_REMOTE_CONFIG:
		packet.nPacketType = RC_LOADDLG;
		packet.nPacketID = 5;
		*((int*) packet.acData) = 1;
		break;

	case TEXT_AP:
		packet.nPacketType = RC_EXTEND;
		packet.nPacketCount = RC_EX_NETWORK;
		*((int*) packet.acData) = EX_WIFI_AP;
		break;

	case TEXT_GET_STREAM:
		packet.nPacketType = RC_LOADDLG;
		packet.nPacketID = 2;
		*((int*) packet.acData) = 1;
		break;

	case TEXT_GET_PTZ:
		packet.nPacketType = RC_LOADDLG;
		packet.nPacketID = 7;
		*((int*) packet.acData) = 1;
		break;

	default:
		break;
	}

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet, size);
		result = JNI_TRUE;
	} else {
		LOGE("sendTextData %d not connect", window);
	}

	LOGV("sendTextData X, %d", result);
	return result;
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_sendCmd(JNIEnv *env, jclass clazz,
		jint window, jbyte uchType, jbyteArray data, jint size) {
	jint result = -1;
	jbyte* cdata = getNativeByteByLength(env, data, 0, size);
	char* echo = byte2echo((BYTE*) cdata, 0, size);
	LOGV( "sendCmd E: window: %d, type: %X, array: %s", window, uchType, echo);

	int index = window2Array(window);
	if (index >= 0) {
		result = JVC_SendCMD(index + 1, (BYTE) uchType, (BYTE*) cdata, size);
	} else {
		LOGE("sendCmd %d not connect", window);
	}

	free(echo);
	free(cdata);

	LOGV("sendCmd X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setWifi(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jstring ssid,
		jstring password, jint flag, jint type) {
	jboolean result = JNI_FALSE;
	char* sid = getNativeChar(env, ssid);
	char* pwd = getNativeChar(env, password);
	LOGV(
			"setWifi E: window: %d, type: %X, ssid: %s, password: %s, flag: %X, type: %X", window, uchType, sid, pwd, flag, type);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_EXTEND;
	packet.nPacketCount = RC_EX_NETWORK;

	EXTEND* pExt;
	pExt = (EXTEND*) packet.acData;
	pExt->acData[0] = 0;
	pExt->nType = type;

	int offset = 0;
	char dummy[256] = { 0 };

	sprintf(dummy, "ACTIVED=%d;", flag); //2
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	sprintf(dummy, "WIFI_ID=%s;", sid);
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	sprintf(dummy, "WIFI_PW=%s;", pwd);
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	pExt->acData[offset] = '\0';

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(pExt->acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("setWifi %d not connect", window);
	}

	free(sid);
	free(pwd);
	LOGV("setWifi X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_saveWifi(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jstring ssid,
		jstring password, jint flag, jint type, jstring auth, jstring enc) {
	jboolean result = JNI_FALSE;
	char* sid = getNativeChar(env, ssid);
	char* pwd = getNativeChar(env, password);
	char* cauth = getNativeChar(env, auth);
	char* cenc = getNativeChar(env, enc);
	LOGV(
			"saveWifi E: window: %d, type: %X, ssid: %s, password: %s, flag: %X, type: %X, auth: %s, enc: %s", window, uchType, sid, pwd, flag, type, cauth, cenc);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_EXTEND;
	packet.nPacketCount = RC_EX_NETWORK;

	EXTEND* pExt;
	pExt = (EXTEND*) packet.acData;
	pExt->acData[0] = 0;
	pExt->nType = type;

	int offset = 0;
	char dummy[256] = { 0 };

	sprintf(dummy, "ACTIVED=%d;", flag); //2
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	sprintf(dummy, "WIFI_ID=%s;", sid);
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	sprintf(dummy, "WIFI_PW=%s;", pwd);
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	sprintf(dummy, "WIFI_AUTH=%s;", cauth);
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	sprintf(dummy, "WIFI_ENC=%s;", cenc);
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	pExt->acData[offset] = '\0';

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(pExt->acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("saveWifi %d not connect", window);
	}

	free(sid);
	free(pwd);
	free(cauth);
	free(cenc);
	LOGV("saveWifi X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setAccessPoint(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jstring json) {
	jboolean result = JNI_FALSE;
	char* cjson = getNativeChar(env, json);
	LOGV(
			"setAccessPoint E: window: %d, type: %X, json: %s", window, uchType, cjson);

	Reader reader;
	Value value;

	if (reader.parse(cjson, value)) {
		PAC packet;
		memset(&packet, 0, sizeof(PAC));
		packet.nPacketType = value["nPacketType"].asInt(); //RC_EXTEND;
		packet.nPacketCount = value["packetCount"].asInt(); //RC_EX_MD;

		WIFI_INFO info;
		memset(&info, 0, sizeof(WIFI_INFO));
		snprintf(info.wifiSsid, sizeof(info.wifiSsid), "%s",
				value["wifiSsid"].asString().c_str());
		snprintf(info.wifiPwd, sizeof(info.wifiPwd), "%s",
				value["wifiPwd"].asString().c_str());

		info.wifiAuth = value["wifiAuth"].asInt();
		info.wifiEncryp = value["wifiEncryp"].asInt();
		info.wifiIndex = value["wifiIndex"].asInt();
		info.wifiChannel = value["wifiChannel"].asInt();
		info.wifiRate = value["wifiRate"].asInt();

		EXTEND *pExt;
		pExt = (EXTEND*) packet.acData;
		pExt->nType = value["nType"].asInt();
		pExt->acData[0] = 0;
		memcpy(pExt->acData, &info, sizeof(WIFI_INFO));

		int index = window2Array(window);
		if (index >= 0) {
			JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
					sizeof(WIFI_INFO) + 20);
			result = JNI_TRUE;
		} else {
			LOGE("setAccessPoint %d not connect", window);
		}

	} else {
		LOGE("setAccessPoint, Bad json!!");
	}

	free(cjson);
	LOGV("setAccessPoint X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setDhcp(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jint dhcp, jstring ip,
		jstring mask, jstring gateway, jstring dns) {
	jboolean result = JNI_FALSE;
	char* cip = getNativeChar(env, ip);
	char* cmask = getNativeChar(env, mask);
	char* cgateway = getNativeChar(env, gateway);
	char* cdns = getNativeChar(env, dns);
	LOGV(
			"setDhcp E: window: %d, type: %X, dhcp: %X, ip: %s, mask: %s, gateway: %s, dns: %s", window, uchType, dhcp, cip, cmask, cgateway, cdns);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_EXTEND;
	packet.nPacketCount = RC_EX_NETWORK;

	EXTEND *pExt;
	pExt = (EXTEND*) packet.acData;
	pExt->acData[0] = 0;
	pExt->nType = EX_NW_SUBMIT;

	int offset = 0;
	char dummy[256] = { 0 };

	sprintf(dummy, "ACTIVED=%d;", 0); //0
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	sprintf(dummy, "bDHCP=%d;", dhcp);
	strcat(pExt->acData + offset, dummy);
	offset += strlen(dummy);

	// [Neo] static, not dhcp
	if (0 == dhcp) {
		u_int32_t _uip = inet_addr(cip);
		sprintf(dummy, "nlIP=%d;", HTONL(_uip));
		strcat(pExt->acData + offset, dummy);
		offset += strlen(dummy);

		u_int32_t _uNM = inet_addr(cmask);
		sprintf(dummy, "nlNM=%d;", HTONL(_uNM));
		strcat(pExt->acData + offset, dummy);
		offset += strlen(dummy);

		u_int32_t _uGW = inet_addr(cgateway);
		sprintf(dummy, "nlGW=%d;", HTONL(_uGW));
		strcat(pExt->acData + offset, dummy);
		offset += strlen(dummy);

		u_int32_t _uDns = inet_addr(cdns);
		sprintf(dummy, "nlDNS=%d;", HTONL(_uDns));
		strcat(pExt->acData + offset, dummy);
		offset += strlen(dummy);
	}

	pExt->acData[offset] = '\0';

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(pExt->acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("setDhcp %d not connect", window);
	}

	free(cip);
	free(cmask);
	free(cgateway);
	free(cdns);
	LOGV( "setDhcp X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_changeStream(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jstring cmd) {
	jboolean result = JNI_FALSE;
	char* ccmd = getNativeChar(env, cmd);
	LOGV(
			"changeStream E: window: %d, type: %X, cmd: %s", window, uchType, ccmd);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_SETPARAM;

	sprintf(packet.acData, "%s", ccmd);

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(packet.acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("changeStream %d not connect", window);
	}

	free(ccmd);
	LOGV( "changeStream X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setDeviceName(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jstring cmd) {
	jboolean result = JNI_FALSE;
	char* ccmd = getNativeChar(env, cmd);
	LOGV(
			"setDeviveName E: window: %d, type: %X, cmd: %s", window, uchType, ccmd);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_SETPARAM;

	sprintf(packet.acData, "%s", ccmd);

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(packet.acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("setDeviceName %d not connect", window);
	}

	free(ccmd);
	LOGV( "setDeviceName X, %d", result);
	return result;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_setLanguage(JNIEnv *env,
		jclass clazz, jint typeId) {
	LOGV( "setLanguage E: type: %d", typeId);
	JVC_SetLanguage(typeId);
	LOGV( "setLanguage X");
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_clearBuffer(JNIEnv *env,
		jclass clazz, jint window) {
	jboolean result = JNI_FALSE;
	LOGV( "clearBuffer E: window: %X", window);

	int index = window2Array(window);
	if (index >= 0) {
		JVC_ClearBuffer(index + 1);
		result = JNI_TRUE;
	} else {
		LOGE("clearBuffer %d not connect", window);
	}

	LOGV( "clearBuffer X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_queryDevice(JNIEnv* env,
		jclass clazz, jstring groupId, jint cloudSeeId, jint timeout) {
	jboolean result = JNI_FALSE;
	char* gid = getNativeChar(env, groupId);
	LOGV( "queryDevice E: no: %s%d, timeout = %dms", gid, cloudSeeId, timeout);

	result =
			(1 == JVC_QueryDevice(gid, cloudSeeId, timeout, onQueryDevice)) ?
					JNI_TRUE : JNI_FALSE;

	free(gid);
	LOGV( "queryDevice X");
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_changeDomain(JNIEnv *env,
		jclass clazz, jstring domainName, jstring pathName) {
	jboolean result = JNI_FALSE;
	char* domain = getNativeChar(env, domainName);
	char* path = getNativeChar(env, pathName);
	LOGV( "changeDomain E: domain: %s, path: %s", domain, path);

	result = (JVC_SetDomainName(domain, path)) ? JNI_TRUE : JNI_FALSE;

	free(domain);
	free(path);
	LOGV( "changeDomain X: %d", result);
	return result;
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_searchLanServer(JNIEnv *env,
		jclass clazz, jint localPort, jint serverPort) {
	jint result = -1;
	LOGV( "searchLanServer E: local: %d, server: %d", localPort, serverPort);
	result = JVC_StartLANSerchServer(localPort, serverPort, onSearchLanServer);
	LOGV( "searchLanServer X: %d", result);
	return result;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_stopSearchLanServer(JNIEnv *env,
		jclass clazz) {
	LOGE( "stopSearchLanServer E");
	JVC_StopLANSerchServer();
	LOGE( "stopSearchLanServer X");
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_searchLanDevice(JNIEnv *env,
		jclass clazz, jstring group, jint cloudSeeId, jint cardType,
		jint variety, jstring deviceName, jint timeout, jint frequence) {
	jint result = -1;
	char* gid = getNativeChar(env, group);
	char* name = getNativeChar(env, deviceName);
	LOGE(
			"searchLanDevice E: no: %s%d, cardType: %X, variety: %X, Name: %s, timeout: %dms, frequence: %d", gid, cloudSeeId, cardType, variety, name, timeout, frequence);

	result = JVC_MOLANSerchDevice(gid, cloudSeeId, cardType, variety, name,
			timeout, frequence);

	free(gid);
	free(name);
	LOGE( "searchLanDevice X: %d", result);
	return result;
}
JNIEXPORT jint JNICALL Java_com_jovision_Jni_getChannelCount(JNIEnv *env,
		jclass clazz, jstring group, jint cloudSeeId, jint timeout) {
	jint result = -1;
	char* gid = getNativeChar(env, group);
	LOGV(
			"getChannelCount E: no: %s%d, timeout: %ds", gid, cloudSeeId, timeout);

	result = JVC_WANGetChannelCount(gid, cloudSeeId, timeout);

	free(gid);
	LOGV( "getChannelCount X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_enableLinkHelper(JNIEnv *env,
		jclass clazz, jboolean enable, jint typeId, jint maxLimit) {
	jboolean result = JNI_FALSE;
	LOGV(
			"enableLinkHelper E: enable: %d, typeId: %d, maxLimit: %d", enable, typeId, maxLimit);

	has_link_enabled = (JNI_TRUE == enable) ? true : false;
	result =
			(JVC_EnableHelp((has_link_enabled) ? 1 : 0, typeId, maxLimit)) ?
					JNI_TRUE : JNI_FALSE;

	LOGV( "enableLinkHelper X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setLinkHelper(JNIEnv *env,
		jclass clazz, jstring json) {
	jboolean result = JNI_FALSE;

	if (false == has_link_enabled) {
		LOGE( "setLinkHelper must be called after enableLinkHelper!!");
		return result;
	}

	char* cjson = getNativeChar(env, json);
	LOGV( "setLinkHelper E: json: %s", cjson);

	Reader reader;
	Value value;

	// [Neo] json -> struct
	if (reader.parse(cjson, value)) {
		int count = value.size();
		int ssize = sizeof(STBASEYSTNO);
		BYTE* buf = (BYTE*) malloc(sizeof(BYTE) * ssize * count);

		for (int i = 0; i < count; i++) {
			Value item = value[i];
			string gid = item["gid"].asString();
			string name = item["name"].asString();
			string pwd = item["pwd"].asString();

			STBASEYSTNO no;
			memset(&no, 0, ssize);
			no.nConnectStatus = 0;
			no.nYSTNO = item["no"].asInt();
			no.nChannel = item["channel"].asInt();
			memcpy(no.chGroup, gid.c_str(), gid.length());
			memcpy(no.chPName, name.c_str(), name.length());
			memcpy(no.chPWord, pwd.c_str(), pwd.length());

			// [Neo] combine the large data
			memcpy(buf + ssize * i, &no, ssize);
		}

		result = (JVC_SetHelpYSTNO(buf, ssize * count)) ? JNI_TRUE : JNI_FALSE;
		free(buf);
	}

	free(cjson);
	LOGV( "setLinkHelper X: %d", result);
	return result;
}

JNIEXPORT jstring JNICALL Java_com_jovision_Jni_getAllDeviceStatus(JNIEnv *env,
		jclass clazz) {
	if (false == has_link_enabled) {
		LOGE( "getAllDeviceStatus must be called after enableLinkHelper!!");
		return env->NewStringUTF("");
	}

	LOGV( "getAllDeviceStatus E");

	int ssize = sizeof(STBASEYSTNO);
	int msize = ssize * 200;

	BYTE* buffer = (BYTE*) malloc(sizeof(BYTE) * msize);
	memset(buffer, 0, msize);

	JVC_GetHelpYSTNO(buffer, &msize);

	int count = msize / ssize;

	Value values, item;
	string result;
	stringstream ss;
	STBASEYSTNO no;

	for (int i = 0; i < count; i++) {
		memcpy(&no, buffer + i * ssize, ssize);
		// [Neo] FIXME: white space will break the stream
		ss << no.chGroup << no.nYSTNO;
		ss >> result;
		ss.clear();
		item["cno"] = result.c_str();
		item["enable"] = (no.nConnectStatus == 1 || no.nConnectStatus == 3);
		values.append(item);
	}

	if (false == values.empty()) {
		FastWriter writer;
		result = writer.write(values);
	} else {
		result = "";
	}

	free(buffer);
	LOGV("getAllDeviceStatus X, json: %s", result.c_str());
	return env->NewStringUTF(result.c_str());
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_isDeviceOnline(JNIEnv *env,
		jclass clazz, jstring group, jint cloudSeeId, jint timeout) {
	jint result = -1;
	char* gid = getNativeChar(env, group);
	LOGV( "isDeviceOnline E: no: %s%d, timeout: %ds", gid, cloudSeeId, timeout);

	result = JVC_GetYSTStatus(gid, cloudSeeId, timeout);

	free(gid);
	LOGV( "isDeviceOnline X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_startRecord(JNIEnv* env,
		jclass clazz, jint window, jstring path, jboolean enableVideo,
		jboolean enableAudio) {
	jboolean result = JNI_FALSE;
	char* cpath = getNativeChar(env, path);

	size_t index_length = strlen(cpath);
	char* index_path = NULL;

	// [Neo] TODO debug for mp4 jdx
	if (index_length > 0) {
		index_path = (char*) malloc(index_length + 1);
		memcpy(index_path, cpath, index_length);
		index_path[index_length - 3] = 'j';
		index_path[index_length - 2] = 'd';
		index_path[index_length - 1] = 'x';
		index_path[index_length] = '\0';
	}

	LOGV(
			"startRecord E: window: %d, path: %s, video: %d, audio: %d", window, cpath, enableVideo, enableAudio);

	int index = window2Array(window);
	if (index >= 0) {

		if (false == g_is_record_mode) {
			player_suit* player = g_player[index];
			if (NULL != player && NULL != g_recorder
					&& NULL == g_recorder->handle && player->is_connected) {

				video_meta* meta = player->vm_normal;
				if (player->is_playback_mode) {
					meta = player->vm_playback;
				}

				PKG_VIDEO_PARAM param = { 0 };

				if (meta->video_width > kMaxMP4VideoWidth
						|| meta->video_height > kMaxMP4VideoHeight) {
					param.iFrameWidth = kMaxMP4VideoWidth;
					param.iFrameHeight = kMaxMP4VideoHeight;
				} else {
					param.iFrameWidth = meta->video_width;
					param.iFrameHeight = meta->video_height;
				}

				param.fFrameRate = meta->video_frame_rate_backup;

				int av_type = meta->audio_type;

				if (av_type < JVS_ACODEC_SAMR || av_type > JVS_ACODEC_ULAW
						|| JNI_FALSE == enableAudio) {
					av_type = 0;
					enableAudio = JNI_FALSE;
				}

				if ((kVTypeH264 == meta->video_type
						|| kVTypeH265 == meta->video_type)
						&& JNI_TRUE == enableVideo) {
					av_type |= (meta->video_type << 8);
				}

				g_recorder->enable_audio =
						(JNI_TRUE == enableAudio) ? true : false;
				g_recorder->enable_video =
						(JNI_TRUE == enableVideo) ? true : false;

				g_recorder->handle = JP_OpenPackage(&param, enableVideo,
						enableAudio, cpath, index_path, av_type, 0);

				if (NULL != g_recorder->handle) {
					g_recorder->need_jump = true;
					g_recorder->window = window;
					g_is_record_mode = true;
					result = JNI_TRUE;
				}
			}
		}

	} else {
		LOGE("startRecord %d not connect", window);
	}

	if (NULL != index_path) {
		free(index_path);
	}

	if (NULL != cpath) {
		free(cpath);
	}
	LOGV( "startRecord X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_checkRecord(JNIEnv* env,
		jclass clazz, jint window) {
	jboolean result =
			(g_is_record_mode && NULL != g_recorder
					&& NULL != g_recorder->handle
					&& window == g_recorder->window) ? JNI_TRUE : JNI_FALSE;
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_stopRecord(JNIEnv *env,
		jclass clazz) {
	jboolean result = JNI_FALSE;
	LOGV( "stopRecord E");

	if (NULL != g_recorder && NULL != g_recorder->handle) {
		JP_ClosePackage(g_recorder->handle);
		g_recorder->handle = NULL;
		result = JNI_TRUE;
	}

	g_is_record_mode = false;

	LOGV( "stopRecord X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_screenshot(JNIEnv *env,
		jclass clazz, jint window, jstring name, jint quality) {
	jboolean result = JNI_FALSE;
	LOGV( "screenshot E: window: %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && player->is_connected) {
			player->screenshot_name = getNativeChar(env, name);
			g_picture_quality = quality;
			if (quality > 0) {
				player->try_screenshot = true;
				result =
						(BAD_SCREENSHOT_NOOP
								== screenshot(index, player->core->yuv)) ?
								JNI_TRUE : JNI_FALSE;
				player->try_screenshot = false;
			} else {
				result = JNI_TRUE;
			}
		}
	} else {
		LOGE("screenshot %d not connect", window);
	}

	LOGV( "screenshot X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setAudioVolume(JNIEnv *,
		jclass, jint window, jfloat gain) {
	jboolean result = JNI_FALSE;
	LOGX( "setAudioVolume E: window: %d, gain: %.1f", window, gain);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player) {
			pthread_mutex_lock(&(player->stat->mutex));//娑�锟斤拷锟斤拷��╋拷锟斤拷锟斤拷锟斤拷unlock���锟芥�达拷�����わ拷锟界�电�帮拷��锟斤拷锟斤拷瑙�锟斤拷lock
			if (NULL != player->track) {
				result = player->track->set_volume(gain) ? JNI_TRUE : JNI_FALSE;
			}
			pthread_mutex_unlock(&(player->stat->mutex));
		}
	} else {
		LOGE("setAudioVolume %d not connect", window);
	}

	LOGX( "setAudioVolume X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setOmx(JNIEnv* env,
		jclass clazz, jint window, jboolean isOmx) {
	jboolean result = JNI_FALSE;
	LOGV( "setOmx E: window: %d, isOmx: %d", window, isOmx);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && player->is_connected
				&& kVTypeH264 == player->vm_normal->video_type) {
			if (JNI_TRUE == isOmx) {
				if (g_has_omx_inited) {
					player->try_fast_forward = true;
					player->try_omx = true;
					result = JNI_TRUE;
				}
			} else {
				player->try_fast_forward = true;
				player->try_omx = false;
				result = JNI_TRUE;
			}
		}
	} else {
		LOGE("setOmx %d not connect", window);
	}

	LOGV( "setOmx X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setColor(JNIEnv* env,
		jclass clazz, jint window, jfloat red, jfloat green, jfloat blue,
		jfloat alpha) {
	jboolean result = JNI_FALSE;
	LOGV(
			"setColor E: window: %d, rgb: (%.2f, %.2f, %.2f), alpha: %.2f", window, red, green, blue, alpha);

	int index = window2Array(window);
	if (index >= 0) {
		color_suit color;
		color.red = red;
		color.green = green;
		color.blue = blue;
		color.alpha = alpha;

		BYTE* o = (BYTE*) malloc(DUMMY_FRAME_SIZE);
		memset(o, 0, DUMMY_FRAME_SIZE);
		o[0] = DUMMY_FRAME_COLOR;
		memcpy(o + 1, &color, sizeof(color_suit));

		offer_video_frame(g_player[index], o, DUMMY_FRAME_SIZE, 0);
		result = JNI_TRUE;
	} else {
		LOGE("setColor %d not connect", window);
	}

	LOGV( "setColor X: %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_fastForward(JNIEnv* env,
		jclass clazz, jint window) {
	jboolean result = JNI_FALSE;
	LOGV( "fastForward E: window: %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player) {
			player->try_fast_forward = true;
			result = JNI_TRUE;
		}
	} else {
		LOGE("fastForward %d not connect", window);
	}

	LOGV( "fastForward X: %d", result);
	return result;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_cancelDownload(JNIEnv* env,
		jclass clazz) {
	pthread_mutex_lock(&g_mutex);
	if (NULL != g_download_file_name) {
		char* name = g_download_file_name;
		g_download_file_name = NULL;

		if (NULL != g_download_file) {
			fclose(g_download_file);
			g_download_file = NULL;
		}

		unlink(name);
		free(name);
		name = NULL;
	}
	pthread_mutex_unlock(&g_mutex);
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_setDownloadFileName(JNIEnv* env,
		jclass clazz, jstring fileName) {
	pthread_mutex_lock(&g_mutex);
	g_download_file_name = getNativeChar(env, fileName);
	pthread_mutex_unlock(&g_mutex);
}

JNIEXPORT jstring JNICALL Java_com_jovision_Jni_getDownloadFileName(JNIEnv* env,
		jclass clazz) {
	pthread_mutex_lock(&g_mutex);
	jstring result = env->NewStringUTF(g_download_file_name);
	pthread_mutex_unlock(&g_mutex);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setStorage(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jstring cmd) {
	jboolean result = JNI_FALSE;
	char* ccmd = getNativeChar(env, cmd);
	LOGV( "setStorage E: window: %d, type: %X, cmd: %s", window, uchType, ccmd);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_SETPARAM;

	sprintf(packet.acData, "%s", ccmd);

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(packet.acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("setStorage %d not connect", window);
	}

	free(ccmd);
	LOGV( "setStorage X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_rotateVideo(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType, jstring cmd) {
	jboolean result = JNI_FALSE;
	char* ccmd = getNativeChar(env, cmd);
	LOGV(
			"rotateVideo E: window: %d, type: %X, cmd: %s", window, uchType, ccmd);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_EXTEND;
	packet.nPacketCount = RC_EX_SENSOR;

	EXTEND* pExt;
	pExt = (EXTEND*) packet.acData;
	pExt->nType = EX_MD_SUBMIT;

	sprintf(pExt->acData, "%s", ccmd);

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(pExt->acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("rotateVideo %d not connect", window);
	}

	free(ccmd);
	LOGV( "rotateVideo X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_updateDevice(JNIEnv *env,
		jclass clazz, jint window, jbyte uchType) {
	jboolean result = JNI_FALSE;
	LOGV( "updateDevice E: window: %d, type: %X", window, uchType);

	PAC packet;
	memset(&packet, 0, sizeof(PAC));
	packet.nPacketType = RC_EXTEND;
	packet.nPacketCount = RC_EX_FIRMUP;

	EXTEND* pExt;
	pExt = (EXTEND*) packet.acData;
	pExt->acData[0] = 0;
	pExt->nType = EX_UPLOAD_START;

	int index = window2Array(window);
	if (index >= 0) {
		JVC_SendData(index + 1, (BYTE) uchType, (BYTE*) &packet,
				strlen(pExt->acData) + 20);
		result = JNI_TRUE;
	} else {
		LOGE("updateDevice %d not connect", window);
	}

	LOGV( "updateDevice X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_enablePlayAudio(JNIEnv *env,
		jclass clazz, jint window, jboolean enable) {
	jboolean result = JNI_FALSE;
	LOGV("enablePlayAudio E: window: %d, enable: %d", window, enable);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && player->is_connected) {
			player->is_play_audio = (JNI_TRUE == enable) ? true : false;
			result = JNI_TRUE;
		}
	} else {
		LOGE("enablePlayAudio %d not connect", window);
	}

	LOGV("enablePlayAudio X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_isPlayAudio(JNIEnv* env,
		jclass clazz, jint window) {
	jboolean result = JNI_FALSE;
	LOGV("isPlayAudio E: window: %d", window);

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player) {
			result = (player->is_play_audio) ? JNI_TRUE : JNI_FALSE;
		}
	} else {
		LOGE("isPlayAudio %d not connect", window);
	}

	LOGV("isPlayAudio X, %d", result);
	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setFrameCounts(JNIEnv* env,
		jclass clazz, jint window, jint min, jint buffer) {
	jboolean result = JNI_FALSE;

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && NULL != player->vm_normal) {
			player->vm_normal->video_frame_min_count = min;
			player->vm_normal->video_frame_buffer_count = buffer;
			result = JNI_TRUE;
		}
	}

	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_setViewPort(JNIEnv* env,
		jclass clazz, jint window, jint left, jint bottom, jint width,
		jint height) {
	jboolean result = JNI_FALSE;

	int index = window2Array(window);
	if (index >= 0) {
		player_suit* player = g_player[index];
		if (NULL != player && player->is_connected
				&& NULL != player->core->opengl_handle) {
			if (1 == width % 2) {
				++width;
			}

			if (1 == height % 2) {
				++height;
			}

			JVO_ViewPort(player->core->opengl_handle, left, bottom, width,
					height);

			BYTE* o = (BYTE*) malloc(DUMMY_FRAME_SIZE);
			memset(o, 0, DUMMY_FRAME_SIZE);
			o[0] = DUMMY_FRAME_DIRTY;
			offer_video_frame(player, o, DUMMY_FRAME_SIZE, 0);

			result = JNI_TRUE;
		}
	} else {
		LOGE("setViewPort %d not connect", window);
	}

	return result;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_initAudioEncoder(JNIEnv* env,
		jclass clazz, jint type, jint sampleRate, jint channelCount,
		jint bitCount, jint block) {
	jboolean result = JNI_FALSE;
	LOGV(
			"initAudioEncoder E: type: %d, sampleRate: %d, channelCount: %d, bitCount: %d, block: %d", type, sampleRate, channelCount, bitCount, block);

	if (NULL == audio_encoder) {
		JAE_PARAM param = { 0 };
		param.iCodecID = type;
		param.sample_rate = sampleRate;
		param.channels = channelCount;
		param.bits_per_sample = bitCount;
		param.bytes_per_block = block;

		audio_encoder = JAE_EncodeOpenEx(&param);

		if (NULL != audio_encoder) {
			result = JNI_TRUE;
		}
	}

	LOGV("initAudioEncoder X, %d", result);
	return result;
}

JNIEXPORT jbyteArray JNICALL Java_com_jovision_Jni_encodeAudio(JNIEnv* env,
		jclass clazz, jbyteArray data) {
	jbyteArray array = NULL;

	jsize size = env->GetArrayLength(data);
	jbyte* in = getNativeByteByLength(env, data, 0, size);
	jbyte* out = NULL;

	if (NULL != audio_encoder && NULL != in) {
		int result = JAE_EncodeOneFrameEx(audio_encoder, (BYTE*) in,
				(BYTE**) &out);
		if (result > 0) {
			array = genByteArray(env, out, 0, result);
		} else {
			LOGE("encodeAudio failed with size = %d!!", size);
		}

		free(in);
	}

	return array;
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_deinitAudioEncoder(JNIEnv* env,
		jclass clazz) {
	jboolean result = JNI_FALSE;
	LOGV("deinitAudioEncoder E");

	if (NULL != audio_encoder) {
		JAE_EncodeCloseEx(audio_encoder);
		audio_encoder = NULL;
		result = JNI_TRUE;
	}

	LOGV("deinitAudioEncoder X, %d", result);
	return result;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_setThumb(JNIEnv *env, jclass clazz,
		jint width, jint quality) {
	g_thumb_width = width >> 1 << 1;
	g_thumb_quality = quality;
}

JNIEXPORT void JNICALL Java_com_jovision_Jni_genVoice(JNIEnv* env, jclass clazz,
		jstring data, jint times) {
	unsigned short buffer[kRateWaveConfig];
	char enc[1024];

	char* cdata = getNativeChar(env, data);
	int len = voiceenc_data2code((unsigned char *) cdata, strlen(cdata),
			(unsigned char *) enc, sizeof(enc));

#ifdef _USE_OPENAL_
	OpenALUtils* utils = new OpenALUtils();
	utils->start(kRateWaveConfig, kChannelMono, kPCM16bit, report_cb);
#else
	AudioTrack* track = new AudioTrack();
	track->start(kRateWaveConfig, kChannelMono, kPCM16bit, report_cb);
#endif

	for (int k = 0; k < times; ++k) {
		for (int i = 0; i < len; ++i) {
			int al = voiceenc_code2pcm_16K16Bit(kRateWaveConfig, 60, enc[i],
					(unsigned char *) buffer, kRateWaveConfig);
#ifdef _USE_OPENAL_
			utils->append((unsigned char*) buffer, al);
#else
			track->append((unsigned char*) buffer, al);
#endif
		}

		if (k < times - 1) {
			memset(buffer, 0, kRateWaveConfig);
#ifdef _USE_OPENAL_
			utils->append((unsigned char*) buffer, kRateWaveConfig);
#else
			track->append((unsigned char*) buffer, kRateWaveConfig);
#endif
			msleep(500);
		}
	}

#ifdef _USE_OPENAL_
#else
	track->fin();
#endif

	free(cdata);
}

JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_tcpConnect(JNIEnv *env,
		jclass clazz, jint window, jint channel, jstring ip, jint port,
		jstring username, jstring password, jint cloudSeeId, jstring groupId,
		jboolean isLocalDetect, jint connectType, jint turnType) {
	jboolean result = JNI_FALSE;
	char* cip = getNativeChar(env, ip);
	char* user = getNativeChar(env, username);
	char* pwd = getNativeChar(env, password);
	char* gid = getNativeChar(env, groupId);
	LOGV(
			"!!! tcpConnect E: window: %d, channel: %d, %s:%d, username: %s, password: %s, no: %s%d, isLocalDetect: %d, connectType: %X, turnType: %X", window, channel, cip, port, user, pwd, gid, cloudSeeId, isLocalDetect, connectType, turnType);

	free(cip);
	free(user);
	free(pwd);
	free(gid);
	LOGV( "!!! tcpConnect X, %d", result);
	return result;
}

JNIEXPORT jstring JNICALL Java_com_jovision_Jni_getBatchChannelCount(JNIEnv *env,
		jclass clazz, jint jtimeouts, jstring jreqjson) {

	int result = -1;

	char *req_json = getNativeChar(env, jreqjson);
	LOGV( "getBatchChannelCount E: req=%s", req_json);


	char* buffer = (char*) malloc(10*1024);
	memset(buffer, 0, 10*1024);

    Reader reader;
    Value req_root;

    Value res_root;
    Value array_obj;
    Value item;
    do{

        if (!reader.parse(req_json, req_root, false))
        {
            result = -9;
            break;
        }

        int size = req_root.size();
        for (int i=0; i<size; ++i)
        {
            Value item1 = req_root[i];
            string group_id = item1["gid"].asString();
            int yst_no = item1["ystno"].asInt();

            LOGE("%d:gid:%s, ystno:%d", i, group_id.c_str(), yst_no);

            memcpy(&buffer[0 + i * 12], group_id.c_str(), group_id.length());
            memcpy(&buffer[4 + i * 12], &yst_no, 4);

        }


        result = JVC_WANGetBatchChannelCount(buffer, size, (int)jtimeouts);


 	    for(int i = 0; i < size; i++)
        {
            unsigned short nChannelNum = 0;
            memcpy(&nChannelNum, &buffer[8 + i * 12], 2);
            LOGE("SEARCH RESULT: %d",nChannelNum);

            Value tmp = req_root[i];

            item["gid"] = tmp["gid"].asString().c_str();
            item["ystno"] = tmp["ystno"].asInt();
            item["chlnum"] = nChannelNum;
            array_obj.append(item);
        }

        res_root["array"] = array_obj;

    }while(0);

    res_root["result"] = result;

    FastWriter writer;
    string str_jsonres = writer.write(res_root);
    free(buffer);
    free(req_json);
    LOGE("getBatchChannelCount X, json: %s", str_jsonres.c_str());
	return env->NewStringUTF(str_jsonres.c_str());
}



/**
 * success:1
 * failed:0
 */

JNIEXPORT jint JNICALL Java_com_jovision_Jni_SetMTU(JNIEnv *env,
		jclass clazz,jint nMtu)
{
	LOGE("Java_com_jovision_Jni_SetMTU");
	return JVC_SetMTU((int)nMtu);
}

/**
 * [IN] pGroup 缂�缁���凤��缂�缁����+nYSTNO���纭�瀹����涓�璁惧��
 * [IN] NYST ���绱㈠�锋�����浜�瑙������风�����璁惧��锛�>0������
 * [RETURN] no
 */
JNIEXPORT void JNICALL Java_com_jovision_Jni_HelperRemove(JNIEnv *env,
		jclass clazz,jstring pGroup,jint nYST)
{
	LOGE("JNICALL Java_com_jovision_Jni_HelperRemove");
	char *pGroupChar = getNativeChar(env, pGroup);
	JVC_HelperRemove(pGroupChar,nYST);
}

/**
 * [IN] pGroup 缂�缁���凤��缂�缁����+nYSTNO���纭�瀹����涓�璁惧��
 * [IN] NYST ���绱㈠�锋�����浜�瑙������风�����璁惧��锛�>0������
 * [RETURN] ��╂�������伴��
 */

JNIEXPORT jint  JNICALL Java_com_jovision_Jni_HelpQuery(JNIEnv *env,
		jclass clazz,jstring pGroup,jint nYST,jint nCount)
{
	int count = 0;
	char *pGroupChar = getNativeChar(env, pGroup);
	 JVC_HelpQuery(pGroupChar,nYST,&count);
	 nCount = count;

	return 0;
}

/**
 * STOP lansearch
 */
JNIEXPORT jint  JNICALL Java_com_jovision_Jni_StopMobLansearch(JNIEnv *env,
		jclass clazz)
{
	return JVC_MOStopLANSerchDevice();
}

JNIEXPORT jint  JNICALL Java_com_jovision_Jni_StopHelp(JNIEnv *env,
		jclass clazz)
{
	return JVC_StopHelp();
}

PlayMP4 *gPlayerMp4 = NULL;

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4Init(JNIEnv *env,
		jclass clazz)
{

    gPlayerMp4 = new PlayMP4();

	return 0;
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_SetMP4Uri(JNIEnv *env,
		jclass clazz,jstring juri)
{
    if(NULL == gPlayerMp4)
    {
        return -100;
    }
    char *uri = getNativeChar(env, juri);
    gPlayerMp4->setURI(uri);
    free(uri);
	return 0;
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4Prepare(JNIEnv *env,
		jclass clazz)
{
    if(NULL == gPlayerMp4)
    {
        return -100;
    }
    return gPlayerMp4->prepare(env);
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4Start(JNIEnv *env,
		jclass clazz, jobject jsurface)
{
    if(NULL == gPlayerMp4)
    {
        return -100;
    }
    return gPlayerMp4->start(env, jsurface);
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4Stop(JNIEnv *env,
		jclass clazz, int stop_seconds)
{
    if(NULL == gPlayerMp4)
    {
        return -100;
    }
    return gPlayerMp4->stop(stop_seconds);
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4Release(JNIEnv *env,
		jclass clazz)
{
    if(NULL == gPlayerMp4)
    {
        return 0;
    }
    gPlayerMp4->stop(0);
    msleep(300);
    delete gPlayerMp4;
    gPlayerMp4 = NULL;

    return 0;
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4Pause(JNIEnv *env,
		jclass clazz)
{
    if(NULL == gPlayerMp4)
    {
        return 0;
    }

    return gPlayerMp4->pause();
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4Resume(JNIEnv *env,
		jclass clazz)
{
    if(NULL == gPlayerMp4)
    {
        return 0;
    }

    return gPlayerMp4->resume();
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_Mp4State(JNIEnv *env,
		jclass clazz)
{
    if(NULL == gPlayerMp4)
    {
        return 0;
    }
    bool quit_status = gPlayerMp4->GetQuitFlag();
    int run_flag = gPlayerMp4->GetRunFlag();
    int play_status = 0;
    if(quit_status)
    {
        if(run_flag)
        {
            //�����剧嚎绋�姝ｅ�ㄩ����猴��杩�娌″����ㄧ�����锛�搴���ㄦ�鹃��瑕�绛�寰�缁����������寮�濮�������
            play_status = 2;
        }
        else
        {
            play_status = 0;//�����剧嚎绋�宸茬����ㄥ�猴�����浠ユ�����
        }
    }
    else{
        if(run_flag)
        {
            //�����剧嚎绋�姝ｅ�ㄨ��琛�,搴���ㄥ��������瑕������撅�����瑕�������姝㈣��棰�������
            play_status = 1;
        }
        else
        {
            //�����剧嚎绋�娌℃��杩�琛�������宸茬��瀹���ㄦ�ㄥ��
            play_status = 0;
        }
    }
    return play_status;
}


//PlayHLS *gPlayHLS = NULL;
JNIEXPORT jboolean JNICALL Java_com_jovision_Jni_CloudStorePlay(JNIEnv *env,
		jclass clazz, jint window, jstring filepath, jstring url, jstring filename, jobject surface,
		jboolean isTryOmx, jstring thumbName, jstring authJson) {

	jboolean result = JNI_FALSE;
	char* file = getNativeChar(env, filepath);
	char* curl = getNativeChar(env, url);
	char* cfilename = getNativeChar(env, filename);
	char* cauthJson = getNativeChar(env, authJson);
#ifdef DEBUG
	LOGI("filePath: %s, url: %s, filename: %s, cauthJson: %s", file, curl, cfilename, cauthJson);
#endif
	//获取窗口号
	int index = getValidArrayIndex(window);
	LOGI("jni cloud play window:%d", window);
	LOGI("jni cloud play index:%d", index);
	if (index >= 0) {
		player_suit* player = genPlayer(index);

		if (NULL != surface && glAttach(env, player, surface)) {
			player->try_omx = false;
			player->is_play_audio = true;

			//启动播放视频线程
			pthread_t pt;
			pthread_create(&pt, NULL, onPlayVideo, (void*) 0);
			//初始化hls播放器
//			gPlayHLS = new PlayHLS();
//			gPlayHLS->
			playerInit(file, curl, cfilename,cauthJson);

		} else {
			LOGW( "glAttach[%d], attach failed", window);
			deletePlayer(index);
		}
	}
	LOGI("jni play hls over!!");
	return JNI_TRUE;
}

JNIEXPORT jint JNICALL Java_com_jovision_Jni_CloudStoreClose(JNIEnv *env,
		jclass clazz)
{
	LOGE("CloudStoreClose ----start");
	playerClose();
	LOGE("CloudStoreClose ---end");
	return 0;
}



static long Post_Response(void *data, int size, int nmemb, std::string &content)
{
	long sizes = size * nmemb;
	std::string temp((char*)data,sizes);
	content += temp;
	LOGE("SIZE: %d",sizes);
	return sizes;
}



FILE *fout = NULL;
JNIEXPORT void JNICALL Java_com_jovision_Jni_NotifytoJni(JNIEnv *env,
		jclass clazz,jstring filename) {
//	FILE *fp = NULL;

//		jboolean isCopy;
//		char *pServerURLChar=0;
//		pServerURLChar = (char *)env->GetStringUTFChars(filename,&isCopy);
//		fout = fopen(pServerURLChar, "wb");
//		if (fout == NULL) {
//			LOGE("could not open %s\n", filename);
//			if (isCopy==JNI_TRUE) {
//						env->ReleaseStringUTFChars(filename,pServerURLChar);
//			}
//			return;
//		}
//
//
//
//		downloadFile(fout,"http://jovetech.oss-cn-hangzhou.aliyuncs.com/B129109013/2015/6/25/M01235851.m3u8?Expires=1435661015&OSSAccessKeyId=4fZazqCFmQTbbmcw&Signature=nILTXUMQ%2FBVUzkjp1RnE069QL68%3D");
//
//		if (isCopy==JNI_TRUE) {
//						env->ReleaseStringUTFChars(filename,pServerURLChar);
//		}

}

#endif // CASTRATE
