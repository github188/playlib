// Generated by Neo

#include <sstream>

#include "defines.h"
#include "utils/commons.h"
#include "utils/threads.h"
#include "utils/callbacks.h"
#include "utils/char_conv.h"

#include <json.h>
#include <net_defs.h>

using namespace Json;

JavaVM* g_jvm;
jobject g_handle;
jmethodID g_notifyid;

bool g_is_record_mode;

FILE* g_download_file;
char* g_download_file_name;

struct recorder_suit* g_recorder;

void ConnectChangeRTMP(int index, BYTE type, char* msg, int data) {
	index = index - 1;
	int window = array2Window(index);
	type |= 0xA0;

	LOGW( "%s [%p]: E, window = %d, type = 0x%02X", LOCATE_PT, window, type);

	if (window >= 0) {

		jboolean needDetach = JNI_FALSE;
		JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
		if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
//			Value values;
//			FastWriter writer;
//
//			if (NULL != umsg && strlen(umsg) > 0) {
//				values["msg"] = umsg;
//			} else {
//				values["msg"] = "";
//			}
//
//			jstring jmsg = env->NewStringUTF(writer.write(values).c_str());
			jstring jmsg = NULL;
			env->CallVoidMethod(g_handle, g_notifyid, CALL_CONNECT_CHANGE,
					(jint) window, (jint) type, jmsg);
//			env->DeleteLocalRef(jmsg);

			if (JNI_TRUE == needDetach) {
				g_jvm->DetachCurrentThread();
			}
		} else {
			LOGE(
					"%s [%p]: window = %d cannot callback to java", LOCATE_PT, window);
		}

		player_suit* player = g_player[index];

		if (RTMP_CONN_FAILED == type || RTMP_DISCONNECTED == type
				|| RTMP_EDISCONNECT == type) {
			if (NULL != player) {
				player->is_connected = false;
			}
		} else if (RTMP_CONN_SCCUESS == type) {
			if (NULL != player) {
				player->is_connected = true;
			}
		} else {

			LOGX("> other: %d(%d) = %02X", window, index, type);

		}

		if (NULL != player) {
			player->is_connecting = false;
			offer_video_frame(player, NULL, 0, -1);
		}

		LOGW("%s [%p]: X, window = %d", LOCATE_PT, window);

	} else {
		LOGE( "%s [%p]: [%d] = %d, type = %d", LOCATE_PT, index, window, type);
	}
}

void NormalDataRTMP(int index, BYTE type, BYTE* buf, int size, int ts) {
	index = index - 1;
	int window = array2Window(index);

	Value values;
	FastWriter writer;

	string json;
	bool needCallBack = false;

	if (window >= 0) {
		player_suit* player = g_player[index];

		switch (type & 0xFF) {
		case RTMP_TYPE_META: {
			JVRTMP_Metadata_t* rtmp_meta = (JVRTMP_Metadata_t*) buf;

			if (NULL != player) {
				video_meta* meta = player->vm_normal;
				meta->video_type = kVTypeH264;

				meta->is_wait_by_ts = true;

				meta->video_width = rtmp_meta->nVideoWidth;
				meta->video_height = rtmp_meta->nVideoHeight;

				meta->video_frame_rate = (float) rtmp_meta->nVideoFrameRateNum
						/ rtmp_meta->nVideoFrameRateDen;
				meta->video_frame_rate_backup = meta->video_frame_rate;
				meta->video_frame_period =
						(int) (1000 / meta->video_frame_rate);
				meta->video_max_frame_count = meta->video_frame_rate
						* MAX_DELAY_TIMES;

				meta->audio_bit = rtmp_meta->nAudioSampleBits;
				meta->audio_type =
						(rtmp_meta->nAudioDataType == RTMP_TYPE_ALAW) ?
								JAD_CODEC_ALAW : JAD_CODEC_ULAW;
				meta->audio_enc_type = meta->audio_type;
				meta->audio_channel = rtmp_meta->nAudioChannels;
				meta->audio_sample_rate = rtmp_meta->nAudioSampleRate;

				if (player->is_connected && false == player->is_audio_working) {
					pthread_t pt;
					pthread_create(&pt, NULL, onPlayAudio, (void*) index);
				}

				values["width"] = meta->video_width;
				values["height"] = meta->video_height;

				values["is05"] = true;
				values["fps"] = meta->video_frame_rate;

				values["audio_bit"] = meta->audio_bit;
				values["audio_type"] = meta->audio_type;
				values["audio_enc_type"] = meta->audio_enc_type;
				values["audio_channel"] = meta->audio_channel;
				values["audio_sample_rate"] = meta->audio_sample_rate;

				// [Neo] dummy O frame: if omx or legacy, restart
				BYTE* o = (BYTE*) malloc(DUMMY_FRAME_SIZE);
				memset(o, 0, DUMMY_FRAME_SIZE);
				o[0] = DUMMY_FRAME_0_O;

				offer_video_frame(player, o, DUMMY_FRAME_SIZE, type);

				json = writer.write(values);
				needCallBack = true;
			}

			break;
		}

		case RTMP_TYPE_H264_I:
		case RTMP_TYPE_H264_BP: {
#ifdef DEBUG_NETWORK_VIDEO_CALLBACK
			LOGD(
					"%s [%p]: window = %d, video.type = %d, size = %d, ts = %u\n", LOCATE_PT, window, type, size, ts);
#endif

			if (NULL != player && player->is_connected
					&& false == player->is_playback_mode) {

				type = (RTMP_TYPE_H264_I == type) ? JVN_DATA_I : JVN_DATA_P;
				offer_video_frame(player, buf, size, type, false, ts);

				if (g_is_record_mode && NULL != g_recorder
						&& g_recorder->window == window
						&& g_recorder->enable_video
						&& ((kVTypeH264 == player->vm_normal->video_type)
								|| (kVTypeH265 == player->vm_normal->video_type))) {
					pthread_mutex_lock(&(g_recorder->mutex));
					if (NULL != g_recorder->handle) {
						if (JVN_DATA_I == type) {
							g_recorder->need_jump = false;
						}

						if (false == g_recorder->need_jump) {
							AV_PACKET avPkt = { 0 };
							avPkt.pData = buf;
							avPkt.iSize = size;
							avPkt.iType = JVS_PKG_VIDEO;
							JP_PackageOneFrame(g_recorder->handle, &avPkt);
						}
					}
					pthread_mutex_unlock(&(g_recorder->mutex));
				}
			}
			break;
		}

		case RTMP_TYPE_ALAW:
		case RTMP_TYPE_ULAW: {
#ifdef DEBUG_NETWORK_VIDEO_CALLBACK
			LOGD(
					"%s [%p]: window = %d, audio.type = %d, size = %d\n", LOCATE_PT, window, type, size);
#endif

			if (NULL != player && player->is_connected
					&& player->is_audio_working && player->is_play_audio) {

				type = (RTMP_TYPE_ALAW == type) ?
						JAD_CODEC_ALAW : JAD_CODEC_ULAW;

				if (player->vm_normal->audio_type != type) {
					pthread_mutex_lock(&(player->core->audio_queue_mt));
					while (player->core->audio_queue_handle->size() > 0) {
						frame* f = player->core->audio_queue_handle->front();
						player->core->audio_queue_handle->pop();
						destroy(f);
					}
					pthread_mutex_unlock(&(player->core->audio_queue_mt));
					player->vm_normal->audio_type = type;
					player->vm_normal->audio_enc_type = type;
				}

				offer_audio_frame(player, buf, size, false, false, ts);

				if (player->vm_normal->audio_type != AUDIO_PCM_RAW
						&& ((kVTypeH264 == player->vm_normal->video_type)
								|| (kVTypeH265 == player->vm_normal->video_type))
						&& g_is_record_mode && NULL != g_recorder
						&& g_recorder->window == window
						&& g_recorder->enable_audio
						&& NULL != g_recorder->handle
						&& false == g_recorder->need_jump) {
					pthread_mutex_lock(&(g_recorder->mutex));
					AV_PACKET avPkt = { 0 };
					avPkt.pData = buf;
					avPkt.iSize = size;
					avPkt.iType = JVS_PKG_AUDIO;
					JP_PackageOneFrame(g_recorder->handle, &avPkt);
					pthread_mutex_unlock(&(g_recorder->mutex));
				}

			}
			break;
		}

		default:
			break;
		}

		if (needCallBack) {
			jboolean needDetach = JNI_FALSE;
			JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
			if (NULL != env && NULL != g_handle && NULL != g_notifyid) {

				jstring jmsg = NULL;
				if (json.length() > 0) {
					jmsg = env->NewStringUTF(json.c_str());
				}

				env->CallVoidMethod(g_handle, g_notifyid, CALL_NORMAL_DATA,
						(jint) window, (jint) type, jmsg);

				if (JNI_TRUE == needDetach) {
					g_jvm->DetachCurrentThread();
				}
			} else {
				LOGE(
						"%s [%p]: window = %d, cannot callback to java", LOCATE_PT, window);
			}
		}

	} else {
		LOGE( "%s [%p]: [%d] = %d, type = %d", LOCATE_PT, index, window, type);
	}
}

void ConnectChange(int index, BYTE type, char* msg, int data) {
	index = index - 1;
	int window = array2Window(index);

//	GBK* gbk = new GBK(msg);
//	char* umsg = gbk->toUTF8();
//	delete gbk;
	char* umsg = msg;

	if (window >= 0) {
		LOGW(
				"%s [%p]: E, window = %d, type = 0x%x, msg = %s", LOCATE_PT, window, type, umsg);

		player_suit* player = g_player[index];

		jboolean needDetach = JNI_FALSE;
		JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
		if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
			Value values;
			FastWriter writer;

			if (NULL != umsg && strlen(umsg)
					&& JVN_CCONNECTTYPE_CONNERR == type) {
				values["msg"] = umsg;
			} else {
				values["msg"] = "";
			}

			std::string json = writer.write(values);

			jstring jmsg = genString(env, json.c_str(), 0, json.length());
			env->CallVoidMethod(g_handle, g_notifyid, CALL_CONNECT_CHANGE,
					(jint) window, (jint) type, jmsg);
			env->DeleteLocalRef(jmsg);

			if (isDisconnected(type)) {
				LOGE(
						"disconnected, set false, player = %p, window = %d", player, window);
				if (NULL != player) {
					player->is_connected = false;
				}

			} else if (JVN_CCONNECTTYPE_CONNOK == type) {
				if (NULL != player) {
					player->is_turn = !(umsg[1] == 'P' && umsg[2] == '2'
							&& umsg[3] == 'P');
					player->is_connected = true;
				}
			}

			if (NULL != player) {
				player->is_connecting = false;
				offer_video_frame(player, NULL, 0, -1);
			}

			if (JNI_TRUE == needDetach) {
				g_jvm->DetachCurrentThread();
			}

			LOGW("%s [%p]: X, window = %d", LOCATE_PT, window);

		} else {
			LOGE(
					"%s [%p]: window = %d cannot callback to java", LOCATE_PT, window);
		}

	} else {
		LOGE( "%s [%p]: [%d] = %d, type = %d", LOCATE_PT, index, window, type);
	}
}

void PlayData(int index, BYTE type, BYTE* buf, int size, int width, int height,
		int frameCount) {
	// [Neo] some default values
	float fps = 12.5f;
	int perFrameDelay = 80, oWidth = -1, oHeight = -1, frameTotalCount = -1;

	Value values;
	FastWriter write;

	// [Neo] useless
	values["count"] = frameCount;

	player_suit* player = NULL;
	video_meta* meta = NULL;

	index = index - 1;
	int window = array2Window(index);

	if (window >= 0) {
		player = g_player[index];

		if (NULL != player) {
			meta = player->vm_playback;
		}
	} else {
		LOGE("%s [%p]: [%d] = %d", LOCATE_PT, index, window);
		return;
	}

	if (0 != size) {

		switch (type) {
		case JVN_DATA_O: {
			// [Neo] dump O frame
			char* echo = byte2echo(buf, 0, size);
			LOGV( "%s [%p]: window = %d, Frame O\n%s", LOCATE_PT, window, echo);
			free(echo);

			if (NULL != meta) {
				memcpy(meta, player->vm_normal, sizeof(video_meta));

				if (checkHeader(buf, size)) {
					JVS_FILE_HEADER_EX fileHeader;
					memcpy(&oWidth, buf + 6, 4);
					memcpy(&oHeight, buf + 10, 4);

					size_t header_size = sizeof(JVS_FILE_HEADER_EX);
					memset(&fileHeader, 0, header_size);
					memcpy(&fileHeader, buf + 2, header_size);

					fps = ((double) fileHeader.wFrameRateNum)
							/ ((double) fileHeader.wFrameRateDen);
					perFrameDelay = 1000 / fps;
					frameTotalCount = fileHeader.dwRecFileTotalFrames;

					meta->video_type = (VideoType) fileHeader.wVideoCodecID;

					// [Neo] just add audio meta
					meta->audio_type = getUsefulAudioType(
							fileHeader.wAudioCodecID);
					meta->audio_sample_rate = fileHeader.wAudioSampleRate;
					meta->audio_channel = fileHeader.wAudioChannels;
					meta->audio_bit = fileHeader.wAudioBits;

					values["audio_type"] = meta->audio_type;
					values["audio_sample_rate"] = meta->audio_sample_rate;
					values["audio_channel"] = meta->audio_channel;
					values["audio_bit"] = meta->audio_bit;

					player->is_JFH = true;

				} else {

					if ((*(unsigned int*) buf & 0xFFFFFF) != 0x53564a) {
						memcpy(&oWidth, buf, 4);
						memcpy(&oHeight, buf + 4, 4);
						if (size >= 12) {
							memcpy(&frameTotalCount, buf + 8, 4);
						} else {
							frameTotalCount = 0;
						}
					} else {
						memcpy(&oWidth, buf + 4, 4);
						memcpy(&oHeight, buf + 8, 4);
					}

				}

				player->is_play_audio = false;

				meta->video_width = oWidth;
				meta->video_height = oHeight;

				meta->video_frame_rate = fps;
				meta->video_frame_rate_backup = fps;
				meta->video_frame_period = perFrameDelay;
				meta->video_max_frame_count = frameTotalCount;

				values["width"] = oWidth;
				values["height"] = oHeight;
				values["fps"] = fps;
				values["total"] = frameTotalCount;

				// [Neo] dummy O frame: if omx, restart
				BYTE* o = (BYTE*) malloc(DUMMY_FRAME_SIZE);
				memset(o, 0, DUMMY_FRAME_SIZE);
				o[0] = DUMMY_FRAME_0_O;

				offer_video_frame(player, o, DUMMY_FRAME_SIZE, type);
			}

			break;
		}

		case JVN_DATA_I:
		case JVN_DATA_B:
		case JVN_DATA_P: {
#ifdef DEBUG_NETWORK_VIDEO_CALLBACK
			LOGD(
					"%s [%p]: window = %d, video.type = %d, buf = %p, size = %d", LOCATE_PT, window, type, buf, size);
#endif

			if (NULL != player && player->is_connected
					&& player->is_playback_mode) {

				if (size > 8 && skipHeader(buf)) {
					// [Neo] legacy
					if (kVType04 == player->vm_playback->video_type) {
						unsigned int new_size = *(unsigned int*) (buf + 4);
						size = new_size >> 4 & 0x0FFFFF;

						switch (new_size & 0x0F) {
						case JVS_TYPE_P:
							type = JVN_DATA_P;
							break;

						case JVS_TYPE_IDR:
							type = JVN_DATA_I;
							break;

						case JVS_TYPE_D:
						case JVS_TYPE_AUD:
						case JVS_TYPE_SKIP:
							type = 0xF0;
							break;

						default:
							type = 0xF1;
							break;
						}

						// [Neo] old ones
					} else if (false == player->is_JFH) {
						// [Neo] size from header or won't change
						if (IPC_DEC_STARTCODE != meta->device_start_code
								&& JVSC951_STARTCODE
										!= meta->device_start_code) {
							unsigned int new_size = *(unsigned int*) (buf + 4);
							size = new_size >> 4 & 0x0FFFFF;
						}
					} else {
						// [Neo] just current ones
						size -= 8;
					}

					buf += 8;
				}

				if (type < 0xF0) {
#ifdef DEBUG_NETWORK_VIDEO_CALLBACK
					LOGV(
							"%s [%p]: check: buf = %p, size = %d", LOCATE_PT, buf, size);
#endif
					offer_video_frame(player, buf, size, type, true);

					if (g_is_record_mode && NULL != g_recorder
							&& g_recorder->window == window
							&& g_recorder->enable_video
							&& ((kVTypeH264 == player->vm_playback->video_type)
									|| (kVTypeH265
											== player->vm_playback->video_type))) {

						pthread_mutex_lock(&(g_recorder->mutex));
						if (NULL != g_recorder->handle) {
							if (JVN_DATA_I == type) {
								g_recorder->need_jump = false;
							}

							if (false == g_recorder->need_jump) {
								AV_PACKET avPkt = { 0 };
								avPkt.pData = buf;
								avPkt.iSize = size;
								avPkt.iType = JVS_PKG_VIDEO;
								JP_PackageOneFrame(g_recorder->handle, &avPkt);
							}
						}
						pthread_mutex_unlock(&(g_recorder->mutex));
					}
				}

			}

			break;
		}

		case JVN_DATA_A: {
			if (NULL != player && player->is_connected
					&& player->is_audio_working && player->is_playback_mode
					&& player->is_play_audio) {
				if (size > 8 && skipHeader(buf)) {
					buf = buf + 8;
					size = size - 8;
				}

				offer_audio_frame(player, buf, size, false, true);

				if (player->vm_playback->audio_type != AUDIO_PCM_RAW
						&& ((kVTypeH264 == player->vm_playback->video_type)
								|| (kVTypeH265
										== player->vm_playback->video_type))
						&& g_is_record_mode && NULL != g_recorder
						&& g_recorder->window == window
						&& g_recorder->enable_audio
						&& NULL != g_recorder->handle
						&& false == g_recorder->need_jump) {
					pthread_mutex_lock(&(g_recorder->mutex));
					AV_PACKET avPkt = { 0 };
					avPkt.pData = buf;
					avPkt.iSize = size;
					avPkt.iType = JVS_PKG_AUDIO;
					JP_PackageOneFrame(g_recorder->handle, &avPkt);
					pthread_mutex_unlock(&(g_recorder->mutex));
				}
			}
			break;
		}

		default:
			LOGE(
					"%s [%p]: window = %d, unkown data type: %X", LOCATE_PT, window, type);
			break;
		}

	} else {

		switch (type) {
		case JVN_RSP_PLAYOVER:
			LOGW( "%s [%p]: window = %d, Over", LOCATE_PT, window);
			break;

		case JVN_RSP_PLAYE:
			LOGW( "%s [%p]: window = %d, Error", LOCATE_PT, window);
			break;

		case JVN_RSP_PLTIMEOUT:
			LOGW( "%s [%p]: window = %d, Timeout", LOCATE_PT, window);
			break;
		}

		// [Neo] dummy fin frame: make black screen, add a msg to java layer
		BYTE* fin = (BYTE*) malloc(DUMMY_FRAME_SIZE);
		memset(fin, 0, DUMMY_FRAME_SIZE);
		fin[0] = DUMMY_FRAME_0_FIN;

		offer_video_frame(player, fin, DUMMY_FRAME_SIZE, type);

	}

	jboolean needDetach = JNI_FALSE;
	JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
	if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
		jstring jmsg = NULL;
		jmsg = env->NewStringUTF(write.write(values).c_str());

		env->CallVoidMethod(g_handle, g_notifyid, CALL_PLAY_DATA, (jint) window,
				(jint) type, jmsg);

		if (JNI_TRUE == needDetach) {
			g_jvm->DetachCurrentThread();
		}
	} else {
		LOGE(
				"%s [%p]: window = %d, cannot callback to java", LOCATE_PT, window);
	}

}

void NormalData(int index, BYTE type, BYTE* buf, int size, int width,
		int height) {
	string json;

	bool is05 = true;
	bool needCallBack = false;

	// [Neo] default for soft card board
	float fps = 25.0f;
	int audioType = AUDIO_PCM_RAW, audioEncType = JAE_ENCODER_G729,
			audioBit = 8, audioChannel = 1, audioSampleRate = 8000,
			perFrameDelay = 40, devType = DEVICE_TYPE_SCARD, oWidth = -1,
			oHeight = -1, devStartCode = -1, reserved = -1;

	Value values;
	FastWriter writer;

	player_suit* player = NULL;
	video_meta* meta = NULL;

	index = index - 1;
	int window = array2Window(index);

	if (window >= 0) {
		player = g_player[index];

		if (NULL != player) {
			meta = player->vm_normal;
		}
	} else {
		LOGE( "%s [%p]: [%d] = %d, type = %d", LOCATE_PT, index, window, type);
		return;
	}

	switch (type) {
	case JVN_DATA_O: {

		if (0 == buf[0]) {
			memcpy(&devStartCode, buf + 2, 4);
			memcpy(&oWidth, buf + 6, 4);
			memcpy(&oHeight, buf + 10, 4);
			memcpy(&reserved, buf + 26, 4);

			LOGV(
					"%s [%p]: window = %d, Frame O start: 0x%X, parse: %dx%d(%dx%d), reserved: 0x%X", LOCATE_PT, window, devStartCode, oWidth, oHeight, width, height, reserved);

			switch (devStartCode) {
			case JVN_DSC_DVR:
			case DVR8004_STARTCODE:
				devType = DEVICE_TYPE_DVR;
				audioBit = 8;
				audioType = AUDIO_PCM_RAW;
				audioEncType = AUDIO_PCM_RAW;
				break;

			case JVSC950_STARTCODE:
				devType = DEVICE_TYPE_950;
				audioBit = 8;
				audioType = AUDIO_PCM_RAW;
				audioEncType = JAE_ENCODER_G729;
				break;

			case JVSC951_STARTCODE:
				devType = DEVICE_TYPE_951;
				audioBit = 16;
				audioType = AUDIO_PCM_RAW;
				audioEncType = JAE_ENCODER_G729;
				break;

			case IPC3507_STARTCODE:
			case IPC_DEC_STARTCODE:
				devType = DEVICE_TYPE_IPC;
				audioBit = 16;
				audioType = JAE_ENCODER_ALAW;
				audioEncType = JAE_ENCODER_ALAW;
				break;

			case JVN_NVR_STARTCODE:
				devStartCode = reserved;
				devType = DEVICE_TYPE_NVR;
				audioBit = 16;
				audioType = JAE_ENCODER_ALAW;
				audioEncType = JAE_ENCODER_ALAW;
				break;

			case JVN_DSC_960CARD:
				audioBit = 16;
				audioType = JAE_ENCODER_SAMR;
				audioEncType = JAE_ENCODER_G729;
				break;

			case JVN_DSC_CARD:
			case JVN_DSC_9800CARD:
				is05 = false;
				// [Neo] TODO
				audioBit = 8;
				audioType = AUDIO_PCM_RAW;
				audioEncType = JAE_ENCODER_G729;
				LOGW(
						"%s [%p]: window = %d, legacy card detected", LOCATE_PT, window);
				break;

			default:
				audioBit = 8;
				audioType = AUDIO_PCM_RAW;
				audioEncType = JAE_ENCODER_G729;
				LOGE(
						"%s [%p]: window = %d, default for soft card, startCode = 0x%x!!", LOCATE_PT, window, devStartCode);
				break;
			}

			values["is_jfh"] = false;

			if (checkHeader(buf, size)) {
				JVS_FILE_HEADER_EX fileHeader;
				size_t header_size = sizeof(JVS_FILE_HEADER_EX);
				memset(&fileHeader, 0, header_size);
				memcpy(&fileHeader, buf + 2, header_size);

				fps = ((double) fileHeader.wFrameRateNum)
						/ ((double) fileHeader.wFrameRateDen);
				perFrameDelay = 1000 / fps;

				meta->video_type = (VideoType) fileHeader.wVideoCodecID;

				audioType = getUsefulAudioType(fileHeader.wAudioCodecID);
				audioEncType = audioType;
				audioBit = fileHeader.wAudioBits;
				audioChannel = fileHeader.wAudioChannels;
				audioSampleRate = fileHeader.wAudioSampleRate;

				is05 = true;
				values["is_jfh"] = true;

				if (NULL != meta) {
					player->is_JFH = true;
				}

			} else if (devStartCode == JVN_DSC_960CARD) {

				int frameRate = 0;
				memcpy(&frameRate, buf + 36, 4);
				fps = (double) frameRate / 10000;
				perFrameDelay = 1000 / fps;

				is05 = true;
				values["is_jfh"] = true;

				if (NULL != meta) {
					player->is_JFH = true;
				}

			}

			needCallBack = true;

			if (NULL != meta) {
				meta->video_width = oWidth;
				meta->video_height = oHeight;

				meta->video_frame_rate = fps;
				meta->video_frame_rate_backup = fps;
				meta->video_frame_period = perFrameDelay;
				meta->video_max_frame_count = fps * MAX_DELAY_TIMES;

				if (false == is05) {
					player->try_omx = false;
					meta->video_type = kVType04;
				} else if (kVTypeUnknown == meta->video_type) {
					meta->video_type = kVTypeH264;
				}

				meta->device_start_code = devStartCode;

				meta->audio_bit = audioBit;
				meta->audio_type = audioType;
				meta->audio_enc_type = audioEncType;
				meta->audio_channel = audioChannel;
				meta->audio_sample_rate = audioSampleRate;

				if (player->is_connected && false == player->is_audio_working) {
					pthread_t pt;
					pthread_create(&pt, NULL, onPlayAudio, (void*) index);
				}
			}

			values["width"] = oWidth;
			values["height"] = oHeight;

			values["is05"] = is05;
			values["fps"] = fps;
			values["device_type"] = devType;
			values["start_code"] = devStartCode;
			values["reserved"] = reserved;
			values["auto_stop_recorder"] = false;

			values["audio_bit"] = audioBit;
			values["audio_type"] = audioType;
			values["audio_enc_type"] = audioEncType;
			values["audio_channel"] = audioChannel;
			values["audio_sample_rate"] = audioSampleRate;

			if (g_is_record_mode) {
				g_is_record_mode = false;

				if (NULL != g_recorder) {
					pthread_mutex_lock(&(g_recorder->mutex));
					if (NULL != g_recorder->handle) {
						JP_ClosePackage(g_recorder->handle);
						g_recorder->handle = NULL;
						values["auto_stop_recorder"] = true;
					}
					pthread_mutex_unlock(&(g_recorder->mutex));
				}
			}

			// [Neo] dummy O frame: if omx or legacy, restart
			BYTE* o = (BYTE*) malloc(DUMMY_FRAME_SIZE);
			memset(o, 0, DUMMY_FRAME_SIZE);
			o[0] = DUMMY_FRAME_0_O;

			offer_video_frame(player, o, DUMMY_FRAME_SIZE, type);

			json = writer.write(values);

//		} else {
//			LOGE(
//					"%s [%p]: index = %d, Frame O, bad[0] = %X, should be 0!!", LOCATE_PT, index, buf[0]);
		}

		break;
	}

	case JVN_DATA_I:
	case JVN_DATA_B:
	case JVN_DATA_P: {
#ifdef DEBUG_NETWORK_VIDEO_CALLBACK
		LOGD(
				"%s [%p]: window = %d, video.type = %d, size = %d\n", LOCATE_PT, window, type, size);
#endif

		if (NULL != player && player->is_connected
				&& false == player->is_playback_mode) {
			if (size > 8 && skipHeader(buf)) {
				if (kVType04 == player->vm_normal->video_type) {
					unsigned int new_size = *(unsigned int*) (buf + 4);
					size = new_size >> 4 & 0x0FFFFF;

					switch (new_size & 0x0F) {
					case JVS_TYPE_P:
						type = JVN_DATA_P;
						break;

					case JVS_TYPE_IDR:
						type = JVN_DATA_I;
						break;

					case JVS_TYPE_D:
					case JVS_TYPE_AUD:
					case JVS_TYPE_SKIP:
						type = 0xF0;
						break;

					default:
						type = 0xF1;
						break;
					}
				} else {
					size -= 8;
				}

				buf += 8;
			}

			if (type < 0xF0) {
				offer_video_frame(player, buf, size, type);

				if (((kVTypeH264 == player->vm_normal->video_type)
						|| (kVTypeH265 == player->vm_normal->video_type))
						&& g_is_record_mode && NULL != g_recorder
						&& g_recorder->window == window) {
					pthread_mutex_lock(&(g_recorder->mutex));
					if (NULL != g_recorder->handle) {
						if (JVN_DATA_I == type) {
							g_recorder->need_jump = false;
						}

						if (false == g_recorder->need_jump) {
							AV_PACKET avPkt = { 0 };
							avPkt.pData = buf;
							avPkt.iSize = size;
							avPkt.iType = JVS_PKG_VIDEO;
							int result = JP_PackageOneFrame(g_recorder->handle,
									&avPkt);
							if (1 != result) {
								LOGE("packet new video failed: %d", result);
							}
						}
					}
					pthread_mutex_unlock(&(g_recorder->mutex));
				}
			}
		}

		break;
	}

	case JVN_DATA_A: {
#ifdef DEBUG_PLAY
		LOGV(
				"%s [%p]: window = %d, audio.size = %d\n", LOCATE_PT, window, size);
#endif

		if (NULL != player && player->is_connected && player->is_audio_working
				&& false == player->is_playback_mode && player->is_play_audio) {
			if (size > 8 && skipHeader(buf)) {
				buf += 8;
				size -= 8;
			}

			offer_audio_frame(player, buf, size);

			if (player->vm_normal->audio_type != AUDIO_PCM_RAW
					&& ((kVTypeH264 == player->vm_normal->video_type)
							|| (kVTypeH265 == player->vm_normal->video_type))
					&& g_is_record_mode && NULL != g_recorder
					&& g_recorder->window == window && g_recorder->enable_audio
					&& NULL != g_recorder->handle
					&& false == g_recorder->need_jump) {
				pthread_mutex_lock(&(g_recorder->mutex));
				AV_PACKET avPkt = { 0 };
				avPkt.pData = buf;
				avPkt.iSize = size;
				avPkt.iType = JVS_PKG_AUDIO;
				int result = JP_PackageOneFrame(g_recorder->handle, &avPkt);
				if (1 != result) {
					LOGE("packet new audio failed: %d", result);
				}
				pthread_mutex_unlock(&(g_recorder->mutex));
			}
		}

		break;
	}

	default:
//		LOGE(
//				"%s [%p]: window = %d, unkown data type: %X", LOCATE_PT, window, type);
		break;
	}

	if (needCallBack) {
		jboolean needDetach = JNI_FALSE;
		JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
		if (NULL != env && NULL != g_handle && NULL != g_notifyid) {

			jstring jmsg = NULL;
			if (json.length() > 0) {
				jmsg = env->NewStringUTF(json.c_str());
			}

			env->CallVoidMethod(g_handle, g_notifyid, CALL_NORMAL_DATA,
					(jint) window, (jint) type, jmsg);

			if (JNI_TRUE == needDetach) {
				g_jvm->DetachCurrentThread();
			}
		} else {
			LOGE(
					"%s [%p]: window = %d, cannot callback to java", LOCATE_PT, window);
		}
	}

}

void CheckResult(int index, BYTE* buf, int size) {
	index = index - 1;
	int window = array2Window(index);

	if (window >= 0) {
		LOGW(
				"%s [%p]: E, window = %d, data.size = %d", LOCATE_PT, window, size);

		jboolean needDetach = JNI_FALSE;
		JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
		if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
			jbyteArray jdata = genByteArray(env, (jbyte*) buf, 0, size);
			env->CallVoidMethod(g_handle, g_notifyid, CALL_CHECK_RESULT,
					(jint) window, (jint) 0, jdata);
			env->DeleteLocalRef(jdata);

			if (JNI_TRUE == needDetach) {
				g_jvm->DetachCurrentThread();
			}
		} else {
			LOGE(
					"%s [%p]: window = %d, cannot callback to java", LOCATE_PT, window);
		}

		LOGW("%s [%p]: X, window = %d", LOCATE_PT, window);

	} else {
		LOGE("%s [%p]: [%d] = %d", LOCATE_PT, index, window);
	}
}

void ChatData(int index, BYTE type, BYTE* buf, int size) {
	index = index - 1;
	int window = array2Window(index);

	if (window >= 0) {
		if (JVN_RSP_CHATDATA == type) {
			player_suit* player = g_player[index];

			if (NULL != player) {
				if (JAE_ENCODER_G729 == player->vm_normal->audio_enc_type
						&& 76 == size) {
					buf += 16;
					size -= 16;
				}

#ifdef DEBUG_AUDIO
				LOGX(
						"%s [%p]: window = %d, audio.size = %d", LOCATE_PT, window, size);
#endif

				offer_audio_frame(player, buf, size, true);
			}
		} else {
			LOGXX(
					"%s [%p]: E, window = %d, 0x%X, data.size = %d", LOCATE_PT, window, type, size);

			jboolean needDetach = JNI_FALSE;
			JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
			if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
				jbyteArray jdata = genByteArray(env, (jbyte*) buf, 0, size);
				env->CallVoidMethod(g_handle, g_notifyid, CALL_CHAT_DATA,
						(jint) window, (jint) type, jdata);
				env->DeleteLocalRef(jdata);

				if (JNI_TRUE == needDetach) {
					g_jvm->DetachCurrentThread();
				}
			} else {
				LOGE(
						"%s [%p]: window = %d, cannot callback to java", LOCATE_PT, window);
			}

			LOGW("%s [%p]: X, window = %d", LOCATE_PT, window);
		}
	} else {
		LOGE("%s [%p]: [%d] = %d", LOCATE_PT, index, window);
	}
}

void TextData(int index, BYTE type, BYTE* buf, int size) {
	index = index - 1;
	int window = array2Window(index);

	if (window >= 0) {
		LOGW(
				"%s [%p]: E, window = %d, 0x%X, buf.size = %d", LOCATE_PT, window, type, size);

		jboolean needDetach = JNI_FALSE;
		JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
		if (NULL != env && NULL != g_handle && NULL != g_notifyid) {

			Value values, list;
			FastWriter writer;

			int flag = 0;
			char* pmsg = NULL;
			jstring jmsg = NULL;

			if (JVN_RSP_TEXTDATA == type) {
				PAC stpacket;
				memset(&stpacket, 0, sizeof(PAC));
				memcpy(&stpacket, buf, size);

				unsigned long n = 0;
				memcpy(&n, stpacket.acData, 4);

				char* pdata = stpacket.acData + n;
				EXTEND* _extends = (EXTEND*) stpacket.acData;

				bool matched = false;

				LOGD(
						"TextData.pac type = %d, count = %d, id = %d, len = %d", stpacket.nPacketType, stpacket.nPacketCount, stpacket.nPacketID, stpacket.nPacketLen);
				LOGD(
						"TextData.pac acData = %s", buf);

				values["packet_type"] = stpacket.nPacketType;
				values["packet_count"] = stpacket.nPacketCount;
				values["packet_id"] = stpacket.nPacketID;
				values["packet_length"] = stpacket.nPacketLen;

				values["extend_type"] = _extends->nType;
				values["extend_arg1"] = _extends->nParam1;
				values["extend_arg2"] = _extends->nParam2;
				values["extend_arg3"] = _extends->nParam3;

				switch ((unsigned int) (stpacket.nPacketType)) {
				case RC_EXTEND: {
					LOGD(
							"TextData.ex type = %d, p1 = %d, p2 = %d, p3 = %d", _extends->nType, _extends->nParam1, _extends->nParam2, _extends->nParam3);
					LOGD(
							"TextData.ex acData = %s", _extends->acData);

					switch ((unsigned int) stpacket.nPacketCount) {
					case RC_EX_NETWORK: {
						matched = true;
						if (EX_WIFI_CONFIG == _extends->nType) {
							switch (_extends->nParam1) {
							// [Neo] TODO
							case -1:
								flag = FLAG_CONFIG_ING;
								break;

							case 0:
								flag = FLAG_CONFIG_FAILED;
								break;

							default:
								flag = FLAG_CONFIG_SCCUESS;
								break;
							}

						} else if (EX_WIFI_AP_CONFIG == _extends->nType) {
							flag = EX_WIFI_AP_CONFIG;
							values["result"] = _extends->nParam1;
						} else {
							matched = false;
						}
						break;
					}

					case 0x04: {
						matched = true;
						flag = FLAG_GET_PWD;
						GBK* gbk = new GBK(_extends->acData);
						values["extend_msg"] = gbk->toUTF8();
						delete gbk;
						break;
					}

					case RC_EX_MD: {
						matched = true;
						if (EX_MD_UPDATE == _extends->nType) {
							flag = FLAG_GET_MD_STATE;
							pmsg = byte2char((BYTE*) (_extends->acData),
									_extends->nParam1, _extends->nParam2);
						} else if (EX_MD_SUBMIT == _extends->nType) {
							flag = FLAG_SET_MD_STATE;
						} else {
							matched = false;
						}
						break;
					}

					case RC_EX_STORAGE: {
						matched = true;
						flag = _extends->nType;
						if (EX_STORAGE_REC_ON == _extends->nType) {
//							LOGX(
//									"textdata.storage: rec on, %s", _extends->acData);
						} else if (EX_STORAGE_REC_OFF == _extends->nType) {
//							LOGX( "textdata.storage: rec off");
						} else if (EX_STORAGE_FORMAT == _extends->nType) {
//							LOGX( "textdata.storage: format");
						} else if (EX_STORAGE_REFRESH == _extends->nType) {
						    LOGX( "textdata.storage: refresh, flag=0x07");
						    flag = 0x07;//获取设备SDK存储容量状态
							pmsg = byte2char((BYTE*) (_extends->acData),
									0, _extends->nParam1);

						} else if (EX_STORAGE_SWITCH == _extends->nType) {
							flag = 100;
						} else {
//							LOGX( "textdata.storage: what the fuck");
						}

						break;
					}

					case RC_EX_FlashJpeg: {
						matched = true;
						flag = FLAG_CAPTURE_FLASH;

						player_suit* player = g_player[index];
						if (NULL != player && NULL != player->screenshot_name) {
							if (_extends->nParam1 > 0) {
								FILE* jpg_file = fopen(player->screenshot_name,
										"wb");
								if (NULL != jpg_file) {
									fwrite(_extends->acData, _extends->nParam1,
											1, jpg_file);
									fclose(jpg_file);
									jpg_file = NULL;
									values["result"] = RESULT_SUCCESS;
								} else {
									values["result"] = RESULT_OPEN_FAILED;
								}
							} else {
								values["result"] = RESULT_NO_DATA;
							}
						} else {
							values["result"] = RESULT_NO_FILENAME;
						}
						break;
					}

					default:
						break;
					}

					break;
				}

				case RC_GETPARAM: {
					matched = true;
					flag = FLAG_GET_PARAM;
					pmsg = byte2char((BYTE*) stpacket.acData, 0,
							strlen(stpacket.acData));
					break;
				}

				case RC_SETPARAMOK: {
					matched = true;
					flag = FLAG_SET_PARAM_OK;
					break;
				}

				case RC_GPIN_ADD:
				case RC_GPIN_SET:
				case RC_GPIN_SELECT:
				case RC_GPIN_DEL: {
					matched = true;
					flag = stpacket.nPacketType;
					values["msg"] = stpacket.acData;
					break;
				}

				case RC_LOADDLG: {
					matched = true;
					switch (stpacket.nPacketID) {
					case 5:
						flag = FLAG_WIFI_CONFIG;
						break;

					case 2:
						flag = FLAG_BPS_CONFIG;
						break;

					default:
						break;
					}

					values["msg"] = pdata;
					break;
				}

				default:
					break;

				}

				if (false == matched) {

					switch (_extends->nType) {
					case EX_TRANSPARENT: {
						char msg[_extends->nParam3 + 1];
						sprintf(msg, _extends->acData, _extends->nParam3);
						msg[_extends->nParam3] = '\0';
						LOGV("transparent: %s", msg);
						values["msg"] = msg;
					}
						break;

					case EX_WIFI_AP: {
						flag = FLAG_WIFI_AP;

						Value item;
						size_t wifi_size = sizeof(wifiap_t);
						wifiap_t* wifi = NULL;
						GBK* gbk = new GBK("");

						for (int i = 0; i < _extends->nParam1; i++) {
							wifi =
									(wifiap_t*) (_extends->acData
											+ wifi_size * i);

							char* name = wifi->name;
							ENCODING enc = detectEncoding(name);

							if (GBK_ENC == enc) {
								name = gbk->update(name)->toUTF8();
								LOGX("ssid.gbk: %s", name);
							}

							if (UNKNOW_ENC == enc) {
								char* dummy = byte2echo((BYTE*) name, 0, 32);
								LOGX( "unkown(%d): %s\n%s", enc, name, dummy);
								free(dummy);
								continue;
							}

							item["name"] = name;
							item["pwd"] = wifi->passwd;
							item["quality"] = wifi->quality;
							item["keystat"] = wifi->keystat;
							item["auth"] = wifi->iestat[0];
							item["enc"] = wifi->iestat[1];
							list.append(item);
						}

						delete gbk;
						values["wifi"] = list;
						break;
					}

					default:
						LOGE(
								"%s [%p]: window = %d, more ex types", LOCATE_PT, window);
						break;
					}
				}

			}

			if (NULL != pmsg) {
				values["msg"] = pmsg;
			}

			values["flag"] = flag;

			jmsg = env->NewStringUTF(writer.write(values).c_str());
			env->CallVoidMethod(g_handle, g_notifyid, CALL_TEXT_DATA,
					(jint) window, (jint) type, jmsg);

			// [Neo] TODO
			if (NULL != pmsg) {
				free(pmsg);
			}

			if (NULL != jmsg) {
				env->DeleteLocalRef(jmsg);
			}

			if (JNI_TRUE == needDetach) {
				g_jvm->DetachCurrentThread();
			}

		} else {
			LOGE(
					"%s [%p]: window = %d, cannot callback to java", LOCATE_PT, window);
		}

		LOGW("%s [%p]: X, window = %d", LOCATE_PT, window);

	} else {
		LOGE("%s [%p]: [%d] = %d", LOCATE_PT, index, window);
	}
}

void onSearchLanServer(STLANSRESULT result) {
	jboolean needDetach = JNI_FALSE;
	JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
	if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
		Value values;
		FastWriter writer;

		values["ip"] = result.chClientIP;
		values["gid"] = result.chGroup;
		values["no"] = result.nYSTNO;
		values["type"] = result.nCardType;
		values["count"] = result.nChannelCount;
		values["port"] = result.nClientPort;
		values["variety"] = result.nVariety;
		values["timeout"] = result.bTimoOut;
		values["netmod"] = (result.nNetMod & 0x01);
		values["curmod"] = result.nCurMod;
		jstring jmsg = env->NewStringUTF(writer.write(values).c_str());

		env->CallVoidMethod(g_handle, g_notifyid, CALL_LAN_SEARCH, (jint) 0,
				(jint) 0, jmsg);
		env->DeleteLocalRef(jmsg);

		if (JNI_TRUE == needDetach) {
			g_jvm->DetachCurrentThread();
		}
	} else {
		LOGE("%s [%p]: cannot callback to java", LOCATE_PT);
	}
}

int onQueryDevice(STLANSRESULT* result) {
	int dummy = -1;

	jboolean needDetach = JNI_FALSE;
	JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
	if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
		Value values;
		FastWriter writer;

		values["ip"] = result->chClientIP;
		values["gid"] = result->chGroup;
		values["no"] = result->nYSTNO;
		values["type"] = result->nCardType;
		values["count"] = result->nChannelCount;
		values["port"] = result->nClientPort;
		values["variety"] = result->nVariety;
		values["timeout"] = result->bTimoOut;
		values["netmod"] = (result->nNetMod & 0x01);
		values["curmod"] = result->nCurMod;
		jstring jmsg = env->NewStringUTF(writer.write(values).c_str());

		env->CallVoidMethod(g_handle, g_notifyid, CALL_QUERY_DEVICE, (jint) 0,
				(jint) 0, jmsg);
		env->DeleteLocalRef(jmsg);

		if (JNI_TRUE == needDetach) {
			g_jvm->DetachCurrentThread();
		}
	} else {
		LOGE("%s [%p]: cannot callback to java", LOCATE_PT);
	}

	return dummy;
}

void Download(int index, BYTE type, BYTE* buf, int size, int length) {
	index = index - 1;
	int window = array2Window(index);

	if (window >= 0) {
		LOGV(
				"%s [%p]: E, window = %d, type = 0x%X, size = %d, length = %d", LOCATE_PT, window, type, size, length);

		switch (type) {
		case JVN_RSP_DOWNLOADDATA:
			LOGV( "%s [%p]: E, window = %d, download", LOCATE_PT, window);

			pthread_mutex_lock(&g_mutex);
			if (NULL != g_download_file_name) {
				if (NULL == g_download_file) {
					g_download_file = fopen(g_download_file_name, "wb");
					LOGW(
							"%s [%p]: E, window = %d, open for wirte file", LOCATE_PT, window);
				}

				fwrite(buf, 1, size, g_download_file);
			}
			pthread_mutex_unlock(&g_mutex);
			break;

		case JVN_CMD_DOWNLOADSTOP:
		case JVN_RSP_DOWNLOADOVER:
		case JVN_RSP_DOWNLOADE:
		case JVN_RSP_DLTIMEOUT:
			LOGV( "%s [%p]: E, index = %d, abort", LOCATE_PT, index);

			pthread_mutex_lock(&g_mutex);
			if (NULL != g_download_file_name) {
				if (NULL != g_download_file) {
					fclose(g_download_file);
					g_download_file = NULL;
					LOGW(
							"%s [%p]: E, index = %d, close for open file", LOCATE_PT, index);
				}
			}
			pthread_mutex_unlock(&g_mutex);
			break;

		default:
			break;
		}

		jboolean needDetach = JNI_FALSE;
		JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
		if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
			Value values;
			FastWriter writer;
			values["size"] = size;
			values["length"] = length;

			jstring jmsg = env->NewStringUTF(writer.write(values).c_str());
			env->CallVoidMethod(g_handle, g_notifyid, CALL_DOWNLOAD,
					(jint) window, (jint) type, jmsg);

			if (JNI_TRUE == needDetach) {
				g_jvm->DetachCurrentThread();
			}
		} else {
			LOGE("%s [%p]: cannot callback to java", LOCATE_PT);
		}

		LOGV("%s [%p]: X, window = %d", LOCATE_PT, window);

	} else {
		LOGE("%s [%p]: [%d] = %d", LOCATE_PT, index, window);
	}
}

int onOmxInfo(OMX_INFO * info) {
	int result = -1;

	LOGV( "%s [%p]: E, type = %s", LOCATE_PT, info->sz);

	jboolean needDetach = JNI_FALSE;
	JNIEnv* env = genAttachedEnv(g_jvm, JNI_VERSION_1_6, &needDetach);
	if (NULL != env && NULL != g_handle && NULL != g_notifyid) {
		Value values;
		FastWriter writer;

		values["type"] = info->sz;

		jstring jmsg = env->NewStringUTF(writer.write(values).c_str());

		env->CallVoidMethod(g_handle, g_notifyid, CALL_HDEC_TYPE, (jint) 0,
				(jint) 0, jmsg);
		env->DeleteLocalRef(jmsg);

		if (JNI_TRUE == needDetach) {
			g_jvm->DetachCurrentThread();
		}
	} else {
		LOGE("%s [%p]: cannot callback to java", LOCATE_PT);
	}

	LOGV( "%s [%p]: X", LOCATE_PT);

	return result;
}
